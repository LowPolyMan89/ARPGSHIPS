// ---------- IDamagable.cs ----------

	public interface IDamagable
	{
		public void DoDamage();
	}



// ---------- IVisual.cs ----------
namespace Ships
{
	public interface IVisual
	{
		public abstract void Load();
		public abstract void Unload();
	}
}


// ---------- Battle.cs ----------
using System.Collections.Generic;
using UnityEngine;

namespace Ships
{
	public class Battle : MonoBehaviour
	{
		public static Battle Instance;

		[Header("Battlefield Bounds")]
		public Vector2 MinBounds = new Vector2(-50, -50);
		public Vector2 MaxBounds = new Vector2(50, 50);
		[Header("Runtime")]
		public PlayerShip Player;
		public BattleCamera CameraController;
		public List<ShipBase> AllShips = new();
		public Transform PlayerSpawnPosition;

		private void Awake()
		{
			if(Instance)
				Destroy(gameObject);
			else
				Instance = this;
		}

		public Vector2 ClampPosition(Vector2 pos)
		{
			pos.x = Mathf.Clamp(pos.x, MinBounds.x, MaxBounds.x);
			pos.y = Mathf.Clamp(pos.y, MinBounds.y, MaxBounds.y);
			return pos;
		}

		public bool IsInside(Vector2 pos)
		{
			return pos.x >= MinBounds.x && pos.x <= MaxBounds.x &&
			       pos.y >= MinBounds.y && pos.y <= MaxBounds.y;
		}
		#if UNITY_EDITOR
		private void OnDrawGizmos()
		{
			Gizmos.color = Color.green;
			Vector2 size = MaxBounds - MinBounds;
			Gizmos.DrawWireCube((MinBounds + MaxBounds) / 2f, size);
		}
		#endif
	}
	
}


// ---------- BattleCamera.cs ----------
using UnityEngine;

namespace Ships
{
	public class BattleCamera : MonoBehaviour
	{
		[Header("Follow Settings")]
		public float followSmooth = 0.2f;
		public float moveOffsetStrength = 2f;

		private Vector3 velocity;
		private Camera cam;
		private float fixedZ;

		private void Awake()
		{
			cam = Camera.main;
			fixedZ = transform.position.z;      // фиксируем Z
		}

		private void LateUpdate()
		{
			if (Battle.Instance == null || Battle.Instance.Player == null)
				return;

			FollowPlayer();
		}

		private void FollowPlayer()
		{
			PlayerShip player = Battle.Instance.Player;

			Vector2 basePos = player.transform.position;
			Vector2 offset = player.Velocity.normalized * moveOffsetStrength;
			Vector2 targetPos = basePos + offset;

			Vector3 smoothed = Vector3.SmoothDamp(
				transform.position,
				new Vector3(targetPos.x, targetPos.y, fixedZ),
				ref velocity,
				followSmooth
			);

			smoothed = ClampCameraToBounds(smoothed);
			smoothed.z = fixedZ;

			transform.position = smoothed;
		}

		private Vector3 ClampCameraToBounds(Vector3 pos)
		{
			Battle b = Battle.Instance;

			float camHeight = cam.orthographicSize;
			float camWidth = camHeight * cam.aspect;

			float minX = b.MinBounds.x + camWidth;
			float maxX = b.MaxBounds.x - camWidth;

			float minY = b.MinBounds.y + camHeight;
			float maxY = b.MaxBounds.y - camHeight;

			pos.x = Mathf.Clamp(pos.x, minX, maxX);
			pos.y = Mathf.Clamp(pos.y, minY, maxY);

			return pos;
		}
	}
}


// ---------- BattleLoader.cs ----------
namespace Ships
{
	using UnityEngine;

	public class BattleLoader : MonoBehaviour
	{
		public GameObject PlayerShipPrefab;

		private void Start()
		{
			LoadPlayerShipFromFit();
		}

		private void LoadPlayerShipFromFit()
		{
			var fit = MetaBattleBridge.LastFit;
			if (fit == null) return;

			var hull = HullLoader.Load(fit.SelectedShipId);
			var go = Instantiate(PlayerShipPrefab, Vector3.zero, Quaternion.identity);
			var ship = go.GetComponent<PlayerShip>();

			ship.LoadShipFromConfig(fit.SelectedShipId);
			ship.Init();

			InstallFit(ship, fit.Fit);
		}

		private void InstallFit(PlayerShip ship, ShipFitModel fit)
		{
			foreach (var slot in ship.WeaponController.Weapons)
			{
				//if (!fit.WeaponSlots.TryGetValue(slot.name, out var itemId))
				//	continue;

				//if (itemId != null)
				//	InstallWeapon(slot, itemId);
			}

			// когда появятся ModuleSlots — аналогично
		}

		private void InstallWeapon(WeaponSlot slot, string itemId)
		{
			// читаем JSON оружия, инстансим WeaponBase, подменяем статы
		}
	}

}


// ---------- HitRules.cs ----------
namespace Ships
{
	public class HitRules
	{
		/// <summary>
		/// Может ли объект с hitMask нанести урон объекту targetTeam?
		/// </summary>
		public static bool CanHit(TeamMask hitMask, TeamMask targetTeam)
		{
			return (hitMask & targetTeam) != 0;
		}
	}
}


// ---------- WeaponSectorVisual.cs ----------
using Unity.VisualScripting;
using UnityEngine;

namespace Ships
{
	using UnityEngine;

	[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
	public class WeaponSectorVisual : MonoBehaviour
	{
		public WeaponSlot slot;

		[Header("Visual")] public Color color = new Color(1f, 1f, 1f, 1f);
		public int segments = 48;

		[Header("Arc settings")] public float innerOffset = 3f; // отступ внутренней дуги

		private Mesh mesh;

		private void Awake()
		{
			mesh = new Mesh();
			mesh.name = "WeaponSectorMesh";
			GetComponent<MeshFilter>().mesh = mesh;

			if (!slot)
				slot = GetComponentInParent<WeaponSlot>();
		}

		private void LateUpdate()
		{
			if (!slot || slot.MountedWeapon == null || slot.MountedWeapon.Model == null)
				return;

			// позиция/поворот слота
			transform.position = slot.transform.position;
			transform.rotation = slot.transform.rotation;

			// игнорируем scale родителей
			transform.localScale = Vector3.one;

			float outerRadius = slot.MountedWeapon.Model.Stats.GetStat(StatType.FireRange).Current;
			float innerRadius = Mathf.Max(0, outerRadius - innerOffset);

			GenerateArc(innerRadius, outerRadius, slot.AllowedAngle);
		}

		private void GenerateArc(float innerR, float outerR, float angle)
		{
			mesh.Clear();

			int steps = Mathf.Max(4, segments);
			int vertCount = (steps + 1) * 2;

			Vector3[] verts = new Vector3[vertCount];
			Vector2[] uvs = new Vector2[vertCount];
			int[] tris = new int[steps * 6];

			float parentScale = slot.transform.lossyScale.x;

			innerR /= parentScale;
			outerR /= parentScale;

			int v = 0;

			for (int i = 0; i <= steps; i++)
			{
				float t = i / (float)steps;
				float rad = Mathf.Lerp(-angle, angle, t) * Mathf.Deg2Rad;

				Vector3 dir = new Vector3(Mathf.Cos(rad), Mathf.Sin(rad), 0);

				// внутренняя дуга
				verts[v] = dir * innerR;
				uvs[v] = new Vector2(t, 0f);

				// внешняя дуга
				verts[v + 1] = dir * outerR;
				uvs[v + 1] = new Vector2(t, 1f);

				v += 2;
			}

			int ti = 0;
			for (int i = 0; i < steps; i++)
			{
				int i0 = i * 2;
				int i1 = i0 + 1;
				int i2 = i0 + 2;
				int i3 = i0 + 3;

				tris[ti++] = i1;
				tris[ti++] = i0;
				tris[ti++] = i2;

				tris[ti++] = i1;
				tris[ti++] = i2;
				tris[ti++] = i3;
			}

			mesh.vertices = verts;
			mesh.uv = uvs;
			mesh.triangles = tris;

			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
		}
	}
}


// ---------- IPlayerInput.cs ----------
using UnityEngine;

namespace Ships
{
	public interface IPlayerInput
	{
		Vector2 Steering { get; }
		float Throttle { get; }
	}
}


// ---------- PlayerInputSystem.cs ----------
using Ships;
using UnityEngine;

public class PlayerInputSystem : MonoBehaviour, IPlayerInput
{
	private PlayerControls controls;

	private Vector2 steering;
	private float throttleAxis;

	public Vector2 Steering => steering;      // -1..1 per axis
	public float Throttle => throttleAxis;    // -1..1 (Shift/Ctrl)

	private void Awake()
	{
		controls = new PlayerControls();

		controls.Ship.Steering.performed += ctx =>
			steering = ctx.ReadValue<Vector2>();
		controls.Ship.Steering.canceled += _ =>
			steering = Vector2.zero;

		controls.Ship.Throttle.performed += ctx =>
			throttleAxis = ctx.ReadValue<float>();
		controls.Ship.Throttle.canceled += _ =>
			throttleAxis = 0f;
	}

	private void OnEnable() => controls.Enable();
	private void OnDisable() => controls.Disable();
}


// ---------- PlayerInputUI.cs ----------

namespace Ships
{
	using UnityEngine;
	using UnityEngine.UI;

	public class PlayerInputUI : MonoBehaviour
	{
		public VariableJoystick stick;
		public Slider throttleSlider;

		public Vector2 SteeringUI =>
			stick != null ? new Vector2(stick.Horizontal, stick.Vertical) : Vector2.zero;

		public float SliderValue =>
			throttleSlider != null ? throttleSlider.value : 0f;

		public void SetSlider(float value)
		{
			if (throttleSlider != null)
				throttleSlider.SetValueWithoutNotify(value);
		}
	}

}


// ---------- DamageCalculator.cs ----------
using UnityEngine;

namespace Ships
{
	public static class DamageCalculator
	{
		public static CalculatedDamage CalculateHit(
			float projectileDamage,
			float armorPierce,
			Vector2 hitPoint,
			WeaponBase sourceWeapon,
			ITargetable target,
			bool wasShieldHit
		)
		{
			var result = new CalculatedDamage
			{
				RawDamage = projectileDamage,
				WasShieldHit = wasShieldHit,
				SourceWeapon = sourceWeapon,
				HitPoint = hitPoint
			};

			// ============================================================
			// 1) КРИТ ШАНС
			// ============================================================
			var critChance = sourceWeapon.Model.Stats.GetStat(StatType.CritChance)?.Current ?? 0f;
			var critMult = sourceWeapon.Model.Stats.GetStat(StatType.CritMultiplier)?.Current ?? 1f;

			var isCrit = Random.value < critChance;
			var critDamage = isCrit ? (sourceWeapon.Model.Stats.GetMaximum(StatType.MaxDamage ) * 0.9f) * critMult : projectileDamage;

			result.IsCrit = isCrit;
			result.CritChance = critChance;
			result.CritBonus = isCrit ? critMult : 1f;
			var damage = critDamage;

			// ============================================================
			// 2) Если попали в щит — броню не учитываем
			// ============================================================

			if (wasShieldHit)
			{
				result.AfterShield = damage;
				result.FinalDamage = damage; // щит сам поглотит сколько может
				LogDamage(result);
				return result;
			}

			// ============================================================
			// 3) Броня (по корпусу)
			// ============================================================
			var armor = 0f;
			if (target.TryGetStat(StatType.Armor, out var armorStat))
				armor = armorStat.Current;

			var effectiveArmor = Mathf.Max(armor - armorPierce, 0);
			var dmgAfterArmor = damage * (100f / (100f + effectiveArmor));

			result.AfterArmor = dmgAfterArmor;
			result.FinalDamage = dmgAfterArmor;

			LogDamage(result);
			return result;
		}


		private static void LogDamage(CalculatedDamage cd)
		{
			Debug.Log(
				$"[DamageCalc] Raw={cd.RawDamage} | " +
				$"ShieldHit={cd.WasShieldHit} | " +
				$"AfterShield={cd.AfterShield} | " +
				$"AfterArmor={cd.AfterArmor} | " +
				$"FinalDamage={cd.FinalDamage} |" +
				$"CritChance={cd.CritChance} is Crit: {cd.IsCrit}"
			);
		}
	}

	public class CalculatedDamage
	{
		public float RawDamage;
		public float AfterShield;
		public float AfterArmor;
		public float FinalDamage;
		public bool IsCrit;
		public float CritChance;
		public float CritBonus;
		public Vector2 HitPoint;
		public WeaponBase SourceWeapon;

		public bool WasShieldHit;
		public bool WasDirectHull;
		public ShieldSide? HitShieldSide;
	}
}


// ---------- GameEvent.cs ----------
using System;

namespace Ships
{
	public static class GameEvent
	{
		public static Action<CalculatedDamage> OnTakeDamage;
		public static Action OnUiUpdate;
		public static event Action<PlayerInventoryModel> OnInventoryUpdated;
		public static event Action<InventoryItem> OnItemSelected;
		public static void TakeDamage(CalculatedDamage calculatedDamage)
		{
			UiUpdate();
			OnTakeDamage?.Invoke(calculatedDamage);
		}
		public static void UiUpdate()
		{
			OnUiUpdate?.Invoke();
		}
		public static void InventoryUpdated(PlayerInventoryModel playerInventoryModel)
		{
			OnInventoryUpdated?.Invoke(playerInventoryModel);
		}
		public static void ItemSelected(InventoryItem item)
		{
			OnItemSelected?.Invoke(item);
		}
	}
}


// ---------- ItemGenerator.cs ----------
using System;
using System.IO;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Ships
{
	using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Ships
{
    public static class ItemGenerator
    {
        public static string WeaponConfigsPath =>
            Path.Combine(Application.streamingAssetsPath, "Configs/Weapons");
        public static string ModulesConfigsPath =>
	        Path.Combine(Application.streamingAssetsPath, "Configs/Modules");

        public static string OutputPath =>
            Path.Combine(Application.persistentDataPath, "Inventory");

        // =============================
        // Загрузка всех шаблонов
        // =============================
        public static List<string> LoadWeaponFiles()
        {
            if (!Directory.Exists(WeaponConfigsPath))
                return new List<string>();

            return Directory.GetFiles(WeaponConfigsPath, "*.json")
                .Select(Path.GetFileName)
                .ToList();
        }
        public static List<string> LoadModuleFiles()
        {
	        if (!Directory.Exists(ModulesConfigsPath))
		        return new List<string>();

	        return Directory.GetFiles(ModulesConfigsPath, "*.json")
		        .Select(Path.GetFileName)
		        .ToList();
        }
        // =============================
        // Генерация через LootTable
        // =============================
        public static GeneratedWeaponItem GenerateWeaponFromLoot(string lootTableId)
        {
	        if (!string.IsNullOrEmpty(lootTableId))
	        {
		        var table = LootLoader.Load(lootTableId);
		        if (table != null)
		        {
			        var roll = LootTableSystem.Roll(table);
			        return GenerateWeapon(roll.itemId + ".json", roll.rarity);
		        }
	        }
	        return GenerateWeaponFromAllTemplates();
        }
        public static GeneratedWeaponItem GenerateModuleFromLoot(string lootTableId = null)
        {

	        return GenerateModuleFromAllTemplates();
        }

        public static GeneratedWeaponItem GenerateModule(string templateFile, string forcedRarity)
        {
	        return new GeneratedWeaponItem();
        }

        // =============================
        // Глобальный пул всех оружий
        // =============================
        private static GeneratedWeaponItem GenerateModuleFromAllTemplates()
        {
	        return new GeneratedWeaponItem();
        }
        private static GeneratedWeaponItem GenerateWeaponFromAllTemplates()
        {
	        var files = LoadWeaponFiles();
	        if (files.Count == 0) return null;

	        List<(string template, string rarity, int weight)> pool = new();

	        foreach (var file in files)
	        {
		        var json = File.ReadAllText(Path.Combine(WeaponConfigsPath, file));
		        var template = JsonUtility.FromJson<WeaponTemplate>(json);

		        foreach (var r in template.Rarities)
			        pool.Add((template.Id, r.Rarity, r.DropChance));
	        }

	        var pick = PickGlobal(pool);
	        return GenerateWeapon(pick.template + ".json", pick.rarity);
        }

        private static (string template, string rarity) PickGlobal(
            List<(string template, string rarity, int weight)> entries)
        {
            int total = entries.Sum(e => e.weight);
            int roll = Random.Range(0, total);
            int accum = 0;

            foreach (var e in entries)
            {
                accum += e.weight;
                if (roll < accum)
                    return (e.template, e.rarity);
            }

            return (entries[0].template, entries[0].rarity);
        }

        // =============================
        // Основной метод генерации
        // =============================
        public static GeneratedWeaponItem GenerateWeapon(string templateFile, string forcedRarity)
        {
            var fullPath = Path.Combine(WeaponConfigsPath, templateFile);
            var json = File.ReadAllText(fullPath);

            var template = JsonUtility.FromJson<WeaponTemplate>(json);

            string rarity = forcedRarity == "Random"
                ? PickRandomRarity(template)
                : forcedRarity;

            var rarityData = FindRarity(template, rarity);

            var item = new GeneratedWeaponItem
            {
                ItemId = Services.UniqueIdGenerator.GenerateItemId(),
                TemplateId = template.Id,
                Name = template.Name,
                Rarity = rarity,

                Slot = template.Slot,
                DamageType = template.DamageType,
                Size = template.Size,
                Icon = template.Icon
            };

            List<StatValue> stats = new();
            foreach (var s in rarityData.Stats.Entries)
            {
                float v = Mathf.RoundToInt(Random.Range(s.Min, s.Max));
                stats.Add(new StatValue { Name = s.Name, Value = v });
            }
            item.Stats = stats.ToArray();

            item.Effects = GenerateEffects(template, rarityData);

            SaveItem(item);
            return item;
        }

        // =============================
        // Внутренние хелперы
        // =============================
        private static WeaponTemplate.RarityEntry FindRarity(WeaponTemplate t, string rarity)
        {
            return t.Rarities.FirstOrDefault(
                r => r.Rarity.Equals(rarity, StringComparison.OrdinalIgnoreCase));
        }

        private static string PickRandomRarity(WeaponTemplate tpl)
        {
            int total = tpl.Rarities.Sum(r => r.DropChance);
            int roll = Random.Range(0, total);
            int accum = 0;

            foreach (var r in tpl.Rarities)
            {
                accum += r.DropChance;
                if (roll < accum)
                    return r.Rarity;
            }

            return tpl.Rarities[0].Rarity;
        }

        private static List<string> GenerateEffects(WeaponTemplate tpl, WeaponTemplate.RarityEntry rarity)
        {
            var result = new List<string>();
            int max = rarity.MaxEffectCount;

            if (max <= 0 || tpl.AvailableEffects == null)
                return result;

            int count = Random.Range(0, max + 1);
            HashSet<int> used = new();

            while (result.Count < count)
            {
                int i = Random.Range(0, tpl.AvailableEffects.Length);
                if (used.Add(i))
                    result.Add(tpl.AvailableEffects[i]);
            }

            return result;
        }

        private static void SaveItem(GeneratedWeaponItem item)
        {
            if (!Directory.Exists(OutputPath))
                Directory.CreateDirectory(OutputPath);

            var json = JsonUtility.ToJson(item, true);
            var path = Path.Combine(OutputPath, item.ItemId + ".json");

            File.WriteAllText(path, json);
            Debug.Log("Saved item → " + path);
        }
    }
}


	[Serializable]
	public sealed class WeaponTemplate
	{
		public string Id;
		public string Name;
		public string Icon;
		public string Slot;
		public string DamageType;
		public string Size;

		public string[] AvailableEffects;

		public RarityEntry[] Rarities;

		[Serializable]
		public sealed class RarityEntry
		{
			public string Rarity;
			public int DropChance;
			public int MaxEffectCount;
			public StatList Stats;
		}

		[Serializable]
		public sealed class StatList
		{
			public StatRangeEntry[] Entries;
		}

		[Serializable]
		public sealed class StatRangeEntry
		{
			public string Name;
			public float Min;
			public float Max;
		}
	}

	[Serializable]
	public class GeneratedWeaponItem : IGeneratedItem
	{
		public string ItemId;
		public string TemplateId;
		public string Name;
		public string Rarity;

		public string Slot;
		public string DamageType;
		public string Size;
		public string Icon;

		public StatValue[] Stats;
		public List<string> Effects;
		string IGeneratedItem.ItemId => ItemId;
		string IGeneratedItem.TemplateId => TemplateId;
		string IGeneratedItem.Name => Name;
		string IGeneratedItem.Rarity => Rarity;
	}


	[Serializable]
	public sealed class StatValue
	{
		public string Name;
		public float Value;
	}
}


// ---------- Services.cs ----------
using System;

namespace Ships
{
	public static class Services
	{
		public static class UniqueIdGenerator
		{
			private static readonly char[] Chars =
				"abcdefghijklmnopqrstuvwxyz0123456789".ToCharArray();

			private static readonly System.Random Rnd = new System.Random();

			private static string RandomString(int length)
			{
				var buffer = new char[length];
				for (int i = 0; i < length; i++)
					buffer[i] = Chars[Rnd.Next(Chars.Length)];
				return new string(buffer);
			}
			
			public static string GenerateItemId()
			{
				long timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
				string r = RandomString(4);
				return $"item_{timestamp}_{r}";
			}
		}
	}
	public static class InventoryUtils
	{
		public static InventoryItem FindByItemId(PlayerInventoryModel inv, string itemId)
		{
			return inv.InventoryUniqueItems.Find(i => i.ItemId == itemId);
		}
	}
}


// ---------- CodeCollector.cs ----------
using UnityEditor;
using UnityEngine;
using System.IO;
using System.Linq;

public static class CodeCollector
{
	private const string SourceFolder = "Assets/Scripts";
	private const string OutputFile = "AllSource.txt";

	[MenuItem("Tools/Code Collector/Collect All Scripts")]
	public static void Collect()
	{
		// Находим все .cs файлы
		string[] files = Directory.GetFiles(SourceFolder, "*.cs", SearchOption.AllDirectories);

		if (files.Length == 0)
		{
			Debug.LogWarning("CodeCollector: Не найдено ни одного .cs файла.");
			return;
		}

		// Собираем содержимое
		using (StreamWriter writer = new StreamWriter(OutputFile, false)) // false = перезаписывать каждый раз
		{
			foreach (string file in files)
			{
				writer.WriteLine($"// ---------- {Path.GetFileName(file)} ----------");
				string content = File.ReadAllText(file);
				writer.WriteLine(content);
				writer.WriteLine("\n");
			}
		}

		Debug.Log($"CodeCollector: Готово! Собранно {files.Length} скриптов → {OutputFile}");
		AssetDatabase.Refresh();
	}
}


// ---------- DebugStatsPanel.cs ----------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

using Ships;
using Ships.HitEffect;

public class DebugStatsPanel : EditorWindow
{
    private ShipBase targetShip;

    private Vector2 scrollStats;
    private Vector2 scrollEffects;

    private List<Type> effectTypes = new List<Type>();

    [MenuItem("Tools/Debug/Stats & Effects Panel")]
    public static void Open()
    {
        GetWindow<DebugStatsPanel>("Debug Stats Panel");
    }

    private void OnEnable()
    {
        RefreshEffects();
    }

    private void RefreshEffects()
    {
        effectTypes.Clear();

        var assemblies = AppDomain.CurrentDomain.GetAssemblies();

        foreach (var asm in assemblies)
        {
            foreach (var type in asm.GetTypes())
            {
                if (type.IsAbstract) continue;
                if (!typeof(IOnHitEffect).IsAssignableFrom(type)) continue;

                effectTypes.Add(type);
            }
        }
    }

    private void OnGUI()
    {
        EditorGUILayout.Space();

        DrawTargetSelector();

        EditorGUILayout.Space(8);

        if (targetShip != null)
        {
            DrawStats();
            EditorGUILayout.Space(12);
            DrawEffects();
        }
        else
        {
            EditorGUILayout.HelpBox("Select a ShipBase target.", MessageType.Info);
        }
    }

    private void DrawTargetSelector()
    {
        EditorGUILayout.LabelField("Target Ship", EditorStyles.boldLabel);
        targetShip = (ShipBase)EditorGUILayout.ObjectField(targetShip, typeof(ShipBase), true);

        if (GUILayout.Button("Refresh Effect List"))
        {
            RefreshEffects();
        }
    }

    private void DrawStats()
    {
        EditorGUILayout.LabelField("Stats", EditorStyles.boldLabel);
        scrollStats = EditorGUILayout.BeginScrollView(scrollStats, GUILayout.Height(250));

        foreach (var statPair in targetShip.ShipStats.All)
        {
            var stat = statPair.Value;

            EditorGUILayout.BeginVertical("box");
            EditorGUILayout.LabelField($"{stat.Name}", EditorStyles.boldLabel);
            EditorGUILayout.LabelField($"Base:    {stat.BaseCurrent} / {stat.BaseMaximum}");
            EditorGUILayout.LabelField($"Current: {stat.Current} / {stat.Maximum}");

            if (stat.Modifiers.Count > 0)
            {
                EditorGUILayout.LabelField("Modifiers:");

                foreach (var mod in stat.Modifiers)
                {
                    EditorGUILayout.BeginVertical("box");
                    EditorGUILayout.LabelField($"Type: {mod.Type}");
                    EditorGUILayout.LabelField($"Target: {mod.Target}");
                    EditorGUILayout.LabelField($"Value: {mod.Value}");
                    EditorGUILayout.LabelField($"Periodicity: {mod.Periodicity}");
                    EditorGUILayout.LabelField($"Ticks left: {mod.RemainingTicks}");
                    EditorGUILayout.LabelField($"Source: {mod.Source}");
                    EditorGUILayout.EndVertical();
                }
            }
            else
            {
                EditorGUILayout.LabelField("No modifiers.");
            }

            EditorGUILayout.LabelField("Active Effects", EditorStyles.boldLabel);

            foreach (var e in targetShip.ActiveEffects)
            {
                EditorGUILayout.BeginVertical("box");
                EditorGUILayout.LabelField($"{e.EffectId}  x{e.Stacks}", EditorStyles.boldLabel);
                EditorGUILayout.LabelField($"Time: {e.Remaining:F1}/{e.Duration:F1}");
                EditorGUILayout.EndVertical();
            }

            EditorGUILayout.EndVertical();
        }

        EditorGUILayout.EndScrollView();
    }

    private void DrawEffects()
    {
        EditorGUILayout.LabelField("Available Hit Effects", EditorStyles.boldLabel);
        scrollEffects = EditorGUILayout.BeginScrollView(scrollEffects, GUILayout.Height(300));

        foreach (var type in effectTypes)
        {
            EditorGUILayout.BeginVertical("box");

            EditorGUILayout.LabelField(type.Name, EditorStyles.boldLabel);

            ConstructorInfo ctor = type.GetConstructors().FirstOrDefault();

            if (ctor == null)
            {
                EditorGUILayout.HelpBox("No public constructor found!", MessageType.Error);
                EditorGUILayout.EndVertical();
                continue;
            }

            var parameters = ctor.GetParameters();
            object[] args = new object[parameters.Length];

            for (int i = 0; i < parameters.Length; i++)
            {
                var p = parameters[i];

                // float
                if (p.ParameterType == typeof(float))
                {
                    float def = PlayerPrefs.GetFloat($"{type.Name}_{p.Name}", 1f);
                    float val = EditorGUILayout.FloatField(p.Name, def);
                    PlayerPrefs.SetFloat($"{type.Name}_{p.Name}", val);
                    args[i] = val;
                }
                // int
                else if (p.ParameterType == typeof(int))
                {
                    int def = PlayerPrefs.GetInt($"{type.Name}_{p.Name}", 1);
                    int val = EditorGUILayout.IntField(p.Name, def);
                    PlayerPrefs.SetInt($"{type.Name}_{p.Name}", val);
                    args[i] = val;
                }
                // bool (добавлено!)
                else if (p.ParameterType == typeof(bool))
                {
                    bool def = PlayerPrefs.GetInt($"{type.Name}_{p.Name}", 0) == 1;
                    bool val = EditorGUILayout.Toggle(p.Name, def);
                    PlayerPrefs.SetInt($"{type.Name}_{p.Name}", val ? 1 : 0);
                    args[i] = val;
                }
                // enum
                else if (p.ParameterType.IsEnum)
                {
                    Enum val = (Enum)Enum.Parse(p.ParameterType, p.DefaultValue?.ToString() ?? "0");
                    val = EditorGUILayout.EnumPopup(p.Name, val);
                    args[i] = val;
                }
                else
                {
                    EditorGUILayout.LabelField($"{p.Name}: unsupported type {p.ParameterType.Name}");
                }
            }

            if (GUILayout.Button("Apply To Target"))
            {
                var effect = (IOnHitEffect)ctor.Invoke(args);
                effect.Apply(targetShip, damage: 0, sourceWeapon: null);

                Debug.Log($"[Debug Panel] Applied {type.Name} to {targetShip.name}");
            }

            EditorGUILayout.EndVertical();
        }

        EditorGUILayout.EndScrollView();
    }
}



// ---------- ItemGeneratorEditor.cs ----------
using UnityEditor;
using UnityEngine;

namespace Ships.Editor
{
	public class ItemGeneratorEditor
	{
		[MenuItem("Tools/Generate Item ID")]
		public static void Generate()
		{
			var id = Services.UniqueIdGenerator.GenerateItemId();

			// копируем в буфер обмена
			EditorGUIUtility.systemCopyBuffer = id;

			// показываем всплывающее окно
			EditorUtility.DisplayDialog(
				"Item ID Generated",
				$"ID: {id}\n\nСкопировано в буфер обмена.",
				"OK"
			);

			Debug.Log($"[ItemID] Generated: {id}");
		}
	}
}


// ---------- ItemGeneratorWindow.cs ----------
using UnityEditor;
using UnityEngine;
using System.Collections.Generic;
using System.IO;
using Ships;
using Ships.Ships;

public class ItemGeneratorWindow : EditorWindow
{
    private enum ItemType
    {
        Weapon,
        Module
    }

    private ItemType _selectedType = ItemType.Weapon;

    private List<string> _weaponTemplates = new();
    private List<string> _moduleTemplates = new();

    private int _selectedWeaponTemplate = 0;
    private int _selectedModuleTemplate = 0;

    private string[] _rarities = { "Random", "Common", "Uncommon", "Rare", "Epic", "Legendary" };
    private int _selectedRarity = 0;

    private List<string> _lootTables = new();
    private int _selectedLootTable = 0;

    private int _count = 1;

    // ===================== MENU =====================
    [MenuItem("Tools/Item Generator/Item Generator")]
    public static void Open()
    {
        var w = GetWindow<ItemGeneratorWindow>();
        w.titleContent = new GUIContent("Item Generator");
        w.Show();
    }

    // ===================== INIT =====================
    private void OnEnable()
    {
        _weaponTemplates = ItemGenerator.LoadWeaponFiles();
        _moduleTemplates = ItemGenerator.LoadModuleFiles();
        _lootTables = LoadLootTables();
    }

    // ===================== GUI =====================
    private void OnGUI()
    {
        GUILayout.Label("Item Generator", EditorStyles.boldLabel);

        DrawItemTypeSelection();
        GUILayout.Space(10);

        DrawLootTableSelection();
        GUILayout.Space(10);

        DrawTemplateSelection();
        GUILayout.Space(10);

        DrawRaritySelection();
        GUILayout.Space(10);

        DrawCount();
        GUILayout.Space(15);

        DrawGenerateButton();
        DrawOpenFolderButton();
    }

    // ============================================================
    // UI BLOCKS
    // ============================================================

    private void DrawItemTypeSelection()
    {
        GUILayout.Label("Item Type:", EditorStyles.boldLabel);
        _selectedType = (ItemType)EditorGUILayout.EnumPopup("Type", _selectedType);
    }

    private void DrawLootTableSelection()
    {
        GUILayout.Label("Loot Table (optional):", EditorStyles.boldLabel);

        if (_lootTables.Count == 0)
        {
            GUILayout.Label("No LootTables found");
            return;
        }

        _selectedLootTable = EditorGUILayout.Popup("Loot Table", _selectedLootTable, _lootTables.ToArray());
    }

    private void DrawTemplateSelection()
    {
        GUILayout.Label("Template:", EditorStyles.boldLabel);

        if (_selectedType == ItemType.Weapon)
        {
            if (_weaponTemplates.Count == 0)
            {
                GUILayout.Label("No weapon config files found.");
                return;
            }

            _selectedWeaponTemplate = EditorGUILayout.Popup("Weapon Template", _selectedWeaponTemplate, _weaponTemplates.ToArray());
        }
        else if (_selectedType == ItemType.Module)
        {
            if (_moduleTemplates.Count == 0)
            {
                GUILayout.Label("No module config files found.");
                return;
            }

            _selectedModuleTemplate = EditorGUILayout.Popup("Module Template", _selectedModuleTemplate, _moduleTemplates.ToArray());
        }
    }

    private void DrawRaritySelection()
    {
        GUILayout.Label("Rarity:", EditorStyles.boldLabel);
        _selectedRarity = EditorGUILayout.Popup("Rarity", _selectedRarity, _rarities);
    }

    private void DrawCount()
    {
        _count = EditorGUILayout.IntField("Count", Mathf.Max(1, _count));
    }

    private void DrawGenerateButton()
    {
        if (GUILayout.Button("Generate", GUILayout.Height(35)))
        {
            string selectedLootTable = _lootTables.Count > 0
                ? _lootTables[_selectedLootTable]
                : null;

            for (int i = 0; i < _count; i++)
            {
                switch (_selectedType)
                {
                    case ItemType.Weapon:
                        GenerateWeapon(selectedLootTable);
                        break;

                    case ItemType.Module:
                        GenerateModule(selectedLootTable);
                        break;
                }
            }
        }
    }

    private void DrawOpenFolderButton()
    {
        if (GUILayout.Button("Open Inventory Folder"))
            EditorUtility.RevealInFinder(ItemGenerator.OutputPath);
    }

    // ============================================================
    // GENERATION CALLS
    // ============================================================

    private void GenerateWeapon(string lootTable)
    {
        if (lootTable != null && lootTable != "None")
        {
            ItemGenerator.GenerateWeaponFromLoot(lootTable);
            return;
        }

        // Генерация без LootTable
        ItemGenerator.GenerateWeapon(
            _weaponTemplates[_selectedWeaponTemplate],
            _rarities[_selectedRarity]
        );
    }

    private void GenerateModule(string lootTable)
    {
        if (lootTable != null && lootTable != "None")
        {
            ItemGenerator.GenerateModuleFromLoot(lootTable);
            return;
        }

        ItemGenerator.GenerateModule(
            _moduleTemplates[_selectedModuleTemplate],
            _rarities[_selectedRarity]
        );
    }

    // ============================================================
    // LOAD LOOT TABLES
    // ============================================================

    private List<string> LoadLootTables()
    {
        var result = new List<string>();

        string path = Path.Combine(Application.streamingAssetsPath, "Configs/Loot/LootTables");

        if (!Directory.Exists(path))
            return result;

        var files = Directory.GetFiles(path, "*.json");
        foreach (var f in files)
            result.Add(Path.GetFileNameWithoutExtension(f));

        result.Insert(0, "None"); // выбор "без таблицы"

        return result;
    }
}



// ---------- LootTableTesterWindow.cs ----------
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using Ships;

public class LootTableTesterWindow : EditorWindow
{
    private enum GraphType
    {
        Bars,
        Histogram
    }

    private readonly string[] RARITIES =
        { "Common", "Uncommon", "Rare", "Epic", "Legendary" };

    private List<string> _lootTables = new();
    private int _selectedTable = 0;

    private int _simulationCount = 10000;

    private Dictionary<string, int> _itemCounts = new();
    private Dictionary<string, int> _rarityCounts = new();

    private bool _hasResults = false;

    private GraphType _graphType = GraphType.Bars;

    // --------------------------------------------------
    [MenuItem("Tools/Loot/Loot Table Tester")]
    public static void Open()
    {
        var w = GetWindow<LootTableTesterWindow>();
        w.titleContent = new GUIContent("Loot Tester");
        w.Show();
    }

    // --------------------------------------------------
    private void OnEnable()
    {
        LoadLootTables();
    }

    private void LoadLootTables()
    {
        _lootTables.Clear();

        string lootPath = Path.Combine(
            Application.streamingAssetsPath,
            "Configs/Loot/LootTables"
        );

        if (!Directory.Exists(lootPath))
            return;

        foreach (var file in Directory.GetFiles(lootPath, "*.json"))
            _lootTables.Add(Path.GetFileNameWithoutExtension(file));
    }

    // --------------------------------------------------
    private void OnGUI()
    {
        GUILayout.Label("Loot Table Tester", EditorStyles.boldLabel);

        if (_lootTables.Count == 0)
        {
            GUILayout.Label("No LootTables found.");
            return;
        }

        _selectedTable = EditorGUILayout.Popup("LootTable", _selectedTable, _lootTables.ToArray());
        _simulationCount = EditorGUILayout.IntField("Simulations", _simulationCount);

        _graphType = (GraphType)EditorGUILayout.EnumPopup("Graph Type", _graphType);

        if (GUILayout.Button("Simulate", GUILayout.Height(30)))
        {
            RunSimulation();
        }

        if (_hasResults)
        {
            GUILayout.Space(15);
            DrawResults();
        }
    }

    // --------------------------------------------------
    private void RunSimulation()
    {
        string tableId = _lootTables[_selectedTable];
        var table = LootLoader.Load(tableId);

        _itemCounts.Clear();
        _rarityCounts.Clear();
        _hasResults = false;

        if (table == null)
        {
            Debug.LogError("Error: loot table not found!");
            return;
        }

        for (int i = 0; i < _simulationCount; i++)
        {
            var result = LootTableSystem.Roll(table);

            // count items
            if (!_itemCounts.ContainsKey(result.itemId))
                _itemCounts[result.itemId] = 0;
            _itemCounts[result.itemId]++;

            // count rarities
            if (!_rarityCounts.ContainsKey(result.rarity))
                _rarityCounts[result.rarity] = 0;
            _rarityCounts[result.rarity]++;
        }

        _hasResults = true;
    }

    // --------------------------------------------------
    private void DrawResults()
    {
        GUILayout.Label("Results", EditorStyles.boldLabel);

        GUILayout.Label("Rarity Distribution:");

        if (_graphType == GraphType.Bars)
            DrawRarityBars();
        else
            DrawRarityHistogram();

        GUILayout.Space(20);

        GUILayout.Label("Item Distribution:");

        if (_graphType == GraphType.Bars)
            DrawItemBars();
        else
            DrawItemHistogram();
    }

    // --------------------------------------------------
    // COLORS
    private Color GetColorForRarity(string rarity)
    {
        return rarity switch
        {
            "Common" => Color.white,
            "Uncommon" => new Color(0.5f, 1f, 0.5f),
            "Rare" => new Color(0.3f, 0.6f, 1f),
            "Epic" => new Color(0.7f, 0.2f, 1f),
            "Legendary" => new Color(1f, 0.7f, 0f),
            _ => Color.gray
        };
    }

    // --------------------------------------------------
    // BARS (horizontal)
    private void DrawRarityBars()
    {
        foreach (var rarity in RARITIES)
        {
            if (!_rarityCounts.ContainsKey(rarity))
                continue;

            float pct = (float)_rarityCounts[rarity] / _simulationCount;

            EditorGUILayout.BeginHorizontal();

            GUILayout.Label(rarity, GUILayout.Width(80));

            DrawHorizontalBar(pct, GetColorForRarity(rarity));

            GUILayout.Label($"{pct * 100:F2}% ({_rarityCounts[rarity]})",
                GUILayout.Width(120));

            EditorGUILayout.EndHorizontal();
        }
    }

    private void DrawItemBars()
    {
        foreach (var pair in _itemCounts)
        {
            float pct = (float)pair.Value / _simulationCount;

            EditorGUILayout.BeginHorizontal();

            GUILayout.Label(pair.Key, GUILayout.Width(220));

            DrawHorizontalBar(pct, Color.green);

            GUILayout.Label($"{pct * 100:F2}% ({pair.Value})",
                GUILayout.Width(120));

            EditorGUILayout.EndHorizontal();
        }
    }

    private void DrawHorizontalBar(float pct, Color color)
    {
        Rect r = GUILayoutUtility.GetRect(300, 18);

        EditorGUI.DrawRect(new Rect(r.x, r.y, 300 * pct, r.height), color);
        EditorGUI.DrawRect(new Rect(r.x + 300 * pct, r.y, 300 - 300 * pct, r.height),
            new Color(0, 0, 0, 0.2f));
    }

    // --------------------------------------------------
    // HISTOGRAM (vertical)
    private void DrawRarityHistogram()
    {
        Rect rect = GUILayoutUtility.GetRect(300, 180);
        DrawHistogramBackground(rect);

        float barWidth = rect.width / RARITIES.Length;

        for (int i = 0; i < RARITIES.Length; i++)
        {
            string rarity = RARITIES[i];

            if (!_rarityCounts.ContainsKey(rarity))
                continue;

            float pct = (float)_rarityCounts[rarity] / _simulationCount;

            DrawHistogramBar(rect, i, barWidth, pct, GetColorForRarity(rarity), rarity);
        }
    }

    private void DrawItemHistogram()
    {
        Rect rect = GUILayoutUtility.GetRect(300, 180);
        DrawHistogramBackground(rect);

        float barWidth = rect.width / _itemCounts.Count;

        int i = 0;
        foreach (var kvp in _itemCounts)
        {
            float pct = (float)kvp.Value / _simulationCount;

            DrawHistogramBar(rect, i, barWidth, pct, Color.green, kvp.Key);
            i++;
        }
    }

    // --------------------------------------------------
    // Histogram Helpers
    private void DrawHistogramBackground(Rect rect)
    {
        // фиксированный фон — ограничивает всё
        GUI.BeginClip(rect);
        EditorGUI.DrawRect(new Rect(0, 0, rect.width, rect.height),
            new Color(0.15f, 0.15f, 0.15f));
        GUI.EndClip();
    }

    private void DrawHistogramBar(Rect rect, int index, float barWidth, float pct,
        Color color, string label)
    {
        // ограничиваем область
        GUI.BeginClip(rect);

        // рисуем бар строго внутри 0..rect.height
        float height = rect.height * pct;
        float x = index * barWidth;
        float y = rect.height - height;

        EditorGUI.DrawRect(
            new Rect(x, y, barWidth - 4, height),
            color
        );

        // подпись идет вне clip — иначе обрежется
        GUI.EndClip();

        // рисуем подпись уже в нормальных координатах
        GUI.Label(
            new Rect(rect.x + index * barWidth, rect.yMax + 2, barWidth, 18),
            label,
            EditorStyles.centeredGreyMiniLabel
        );
    }
}



// ---------- ShipDebuggerWindow.cs ----------
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using Ships;

public class ShipDebuggerWindow : EditorWindow
{
    private Vector2 scroll;

    GUIStyle redBold;
    GUIStyle header;
    GUIStyle box;

    [MenuItem("Tools/ARPG SHIPS/Ship Debugger")]
    public static void Open()
    {
        GetWindow<ShipDebuggerWindow>("Ship Debugger");
    }

    private void EnsureStyles()
    {
        if (redBold == null)
        {
            redBold = new GUIStyle(EditorStyles.label)
            {
                normal = { textColor = new Color(1f, 0.25f, 0.25f) },
                fontStyle = FontStyle.Bold
            };
        }

        if (header == null)
        {
            header = new GUIStyle(EditorStyles.boldLabel)
            {
                fontSize = 13
            };
        }

        if (box == null)
        {
            box = new GUIStyle("box")
            {
                padding = new RectOffset(10, 10, 10, 10)
            };
        }
    }

    private void OnGUI()
    {
        EnsureStyles();

        if (!Application.isPlaying)
            return;

        scroll = EditorGUILayout.BeginScrollView(scroll);

        var ships = FindObjectsByType<ShipBase>(FindObjectsSortMode.None);

        foreach (var ship in ships)
        {
            DrawShip(ship);
            GUILayout.Space(15);
        }

        EditorGUILayout.EndScrollView();
    }

    private void DrawShip(ShipBase ship)
    {
        GUILayout.BeginVertical(box);

        EditorGUILayout.LabelField(ship.name, header);

        GUILayout.BeginHorizontal();
        GUILayout.Box("ICON", GUILayout.Width(80), GUILayout.Height(80));

        GUILayout.BeginVertical();
        DrawStats(ship);
        GUILayout.Space(5);
        DrawActiveEffects(ship);
        GUILayout.EndVertical();

        GUILayout.EndHorizontal();

        GUILayout.Space(10);
        DrawWeapons(ship);

        GUILayout.EndVertical();
    }

    private void DrawStats(ShipBase ship)
    {
        foreach (var kv in ship.ShipStats.All)
        {
            Stat stat = kv.Value;
            EditorGUILayout.LabelField($"{kv.Key}: {stat.Current}/{stat.Maximum}");
        }

        foreach (var kv in ship.ShipStats.All)
        {
            Stat stat = kv.Value;

            if (stat.Modifiers.Count == 0)
                continue;

            foreach (var mod in stat.Modifiers)
            {
                string txt = FormatModifier(stat.Name, mod);

                if (mod.Periodicity == StatModifierPeriodicity.Timed)
                    txt += $" ({mod.RemainingTicks}s)";

                EditorGUILayout.LabelField(txt, redBold);
            }
        }
    }

    private string FormatModifier(StatType type, StatModifier mod)
    {
        string sign = mod.Value >= 0 ? "+" : "-";
        float val = Mathf.Abs(mod.Value);

        return mod.Type switch
        {
            StatModifierType.Flat        => $"Buff {sign}{val} {type}",
            StatModifierType.PercentAdd  => $"Buff {sign}{val * 100}% {type}",
            StatModifierType.PercentMult => $"x{1 + mod.Value} {type}",
            StatModifierType.Set         => $"Set {type} = {mod.Value}",
            _ => "Modifier"
        };
    }

    private void DrawActiveEffects(ShipBase ship)
    {
        if (ship.ActiveEffects.Count == 0)
        {
            EditorGUILayout.LabelField("No active effects", EditorStyles.miniLabel);
            return;
        }

        foreach (var eff in ship.ActiveEffects)
        {
            EditorGUILayout.LabelField(
                $"{eff.EffectId} x{eff.Stacks} ({eff.Remaining:F1}/{eff.Duration:F1}s)",
                redBold
            );
        }
    }

    private void DrawWeapons(ShipBase ship)
    {
        if (ship.WeaponController == null)
        {
            EditorGUILayout.LabelField("No weapons", EditorStyles.miniLabel);
            return;
        }

        EditorGUILayout.LabelField("Weapons:", header);

        foreach (var slot in ship.WeaponController.Weapons)
        {
            if (slot == null || slot.MountedWeapon == null)
            {
                EditorGUILayout.LabelField("Slot empty");
                continue;
            }

            var w = slot.MountedWeapon;

            GUILayout.BeginVertical(box);
            EditorGUILayout.LabelField(w.name, EditorStyles.boldLabel);

            if (w.Model != null)
            {
                EditorGUILayout.LabelField(
                    $"FireRate {w.Model.Stats.GetStat(StatType.FireRate).Current}/s " +
                    $"| Speed {w.Model.Stats.GetStat(StatType.ProjectileSpeed).Current} " +
                    $"| Range {w.Model.Stats.GetStat(StatType.FireRange).Current}");

                EditorGUILayout.LabelField(
                    $"Damage {w.Model.Stats.GetStat(StatType.MinDamage).Current}" +
                    $"-{w.Model.Stats.GetStat(StatType.MaxDamage).Current}" +
                    $" | Crit {w.Model.Stats.GetStat(StatType.CritChance).Current * 100}% " +
                    $"x{w.Model.Stats.GetStat(StatType.CritMultiplier).Current}");

                EditorGUILayout.LabelField($"Accuracy {w.Model.Stats.GetStat(StatType.Accuracy).Current}");
            }

            DrawWeaponTargeting(slot);

            GUILayout.EndVertical();
        }
    }

    private void DrawWeaponTargeting(WeaponSlot slot)
    {
        if (slot.WeaponTargeting == null)
            return;

        var wt = slot.WeaponTargeting;

        var f = wt.GetType().GetField("currentTarget",
            System.Reflection.BindingFlags.NonPublic |
            System.Reflection.BindingFlags.Instance);

        var t = f?.GetValue(wt) as ITargetable;

        EditorGUILayout.LabelField(
            "Status: " + (t != null ? "firing" : "idle"),
            t != null ? redBold : EditorStyles.miniLabel);
    }
}



// ---------- UniversalBarEditor.cs ----------
using UnityEngine;
using UnityEditor;

public class UniversalBarEditor : ShaderGUI
{
    private MaterialProperty SafeFind(string name, MaterialProperty[] props)
    {
        try
        {
            return FindProperty(name, props);
        }
        catch
        {
            Debug.LogError("[UniversalBarEditor] Missing property: " + name);
            return null;
        }
    }

    public override void OnGUI(MaterialEditor editor, MaterialProperty[] props)
    {
        // ---- Safely fetch properties ----
        var MainTex    = SafeFind("_MainTex", props);
        var OverlayTex = SafeFind("_OverlayTex", props);
        var GradientTex= SafeFind("_GradientTex", props);

        var Fill       = SafeFind("_Fill", props);
        var InvertFill = SafeFind("_InvertFill", props);
        var FillMode   = SafeFind("_FillMode", props);
        var CutAxis    = SafeFind("_CutAxis", props);

        var UVMinX = SafeFind("_UVMinX", props);
        var UVMaxX = SafeFind("_UVMaxX", props);
        var UVMinY = SafeFind("_UVMinY", props);
        var UVMaxY = SafeFind("_UVMaxY", props);
        var CenterX = SafeFind("_CenterX", props);
        var CenterY = SafeFind("_CenterY", props);

        var GradientDir = SafeFind("_GradientDir", props);

        var PulseEnabled   = SafeFind("_PulseEnabled", props);
        var PulseSpeed     = SafeFind("_PulseSpeed", props);
        var PulseAmplitude = SafeFind("_PulseAmplitude", props);
        var PulseThreshold = SafeFind("_PulseThreshold", props);

        var Tint = SafeFind("_Tint", props);

        EditorGUI.BeginChangeCheck();

        // ============================================
        // BASE TEXTURES
        // ============================================

        EditorGUILayout.LabelField("Base Textures", EditorStyles.boldLabel);

        if (MainTex != null)    editor.TextureProperty(MainTex, "Base");
        if (OverlayTex != null) editor.TextureProperty(OverlayTex, "Overlay");
        if (GradientTex != null)editor.TextureProperty(GradientTex, "Gradient");

        EditorGUILayout.Space(6);

        // ============================================
        // FILL SETTINGS
        // ============================================

        EditorGUILayout.BeginVertical("box");
        EditorGUILayout.LabelField("Fill Settings", EditorStyles.boldLabel);

        if (Fill != null)       editor.ShaderProperty(Fill, "Fill Amount");
        if (InvertFill != null) editor.ShaderProperty(InvertFill, "Invert Fill");
        if (CutAxis != null)    editor.ShaderProperty(CutAxis, "Cut Axis");

        if (FillMode != null)
        {
            string[] options = { "Both Sides", "From Min", "From Max" };
            int f = Mathf.RoundToInt(FillMode.floatValue);
            f = EditorGUILayout.Popup("Fill Mode", f, options);
            FillMode.floatValue = f;
        }

        EditorGUILayout.EndVertical();

        EditorGUILayout.Space(6);

        // ============================================
        // UV AREA
        // ============================================

        EditorGUILayout.BeginVertical("box");
        EditorGUILayout.LabelField("UV Area", EditorStyles.boldLabel);

        if (UVMinX != null) editor.ShaderProperty(UVMinX, "UV Min X");
        if (UVMaxX != null) editor.ShaderProperty(UVMaxX, "UV Max X");
        if (UVMinY != null) editor.ShaderProperty(UVMinY, "UV Min Y");
        if (UVMaxY != null) editor.ShaderProperty(UVMaxY, "UV Max Y");

        if (CenterX != null) editor.ShaderProperty(CenterX, "Center X");
        if (CenterY != null) editor.ShaderProperty(CenterY, "Center Y");

        EditorGUILayout.EndVertical();
        EditorGUILayout.Space(6);

        // ============================================
        // GRADIENT
        // ============================================

        EditorGUILayout.BeginVertical("box");
        EditorGUILayout.LabelField("Gradient", EditorStyles.boldLabel);
        if (GradientDir != null) editor.ShaderProperty(GradientDir, "Gradient Direction");
        EditorGUILayout.EndVertical();

        EditorGUILayout.Space(6);

        // ============================================
        // PULSE
        // ============================================

        EditorGUILayout.BeginVertical("box");
        EditorGUILayout.LabelField("Pulse", EditorStyles.boldLabel);

        if (PulseEnabled != null) editor.ShaderProperty(PulseEnabled, "Enabled");

        if (PulseEnabled != null && PulseEnabled.floatValue > 0.5f)
        {
            if (PulseSpeed != null)     editor.ShaderProperty(PulseSpeed, "Speed");
            if (PulseAmplitude != null) editor.ShaderProperty(PulseAmplitude, "Amplitude");
            if (PulseThreshold != null) editor.ShaderProperty(PulseThreshold, "Threshold");
        }

        EditorGUILayout.EndVertical();
        EditorGUILayout.Space(6);

        // ============================================
        // TINT
        // ============================================

        EditorGUILayout.BeginVertical("box");
        EditorGUILayout.LabelField("Color Tint", EditorStyles.boldLabel);
        if (Tint != null) editor.ShaderProperty(Tint, "Tint");
        EditorGUILayout.EndVertical();

        if (EditorGUI.EndChangeCheck())
            foreach (Material m in editor.targets)
                EditorUtility.SetDirty(m);
    }
}



// ---------- IGeneratedItem.cs ----------
namespace Ships
{
	public interface IGeneratedItem
	{
		string ItemId { get; }
		string TemplateId { get; }
		string Name { get; }
		string Rarity { get; }
	}
}


// ---------- LootLoader.cs ----------
using System.IO;
using UnityEngine;

namespace Ships
{
	public static class LootLoader
	{
		private static readonly string LootPath =
			Path.Combine(Application.streamingAssetsPath, "Configs/Loot/LootTables");

		public static LootTable Load(string id)
		{
			var file = Path.Combine(LootPath, id + ".json");

			if (!File.Exists(file))
			{
				Debug.LogError("LootTable not found: " + file);
				return null;
			}

			var json = File.ReadAllText(file);
			return JsonUtility.FromJson<LootTable>(json);
		}
	}
}


// ---------- LootTable.cs ----------
using System;

namespace Ships
{
	[Serializable]
	public class LootTable
	{
		public string Id;
		public LootEntry[] Drops;
	}

	[Serializable]
	public class LootEntry
	{
		public int Chance;       // шанс выпадения предмета
		public string ItemId;    // шаблон предмета
		public int[] Weights;    // веса редкостей
	}
}


// ---------- LootTableSystem.cs ----------
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Ships
{
	public static class LootTableSystem
	{
		public static (string itemId, string rarity) Roll(LootTable table)
		{
			// 1. Выбираем предмет
			LootEntry entry = RollItem(table);

			// 2. Выбираем его редкость
			string rarity = RollRarity(entry.Weights);

			return (entry.ItemId, rarity);
		}

		private static LootEntry RollItem(LootTable table)
		{
			int total = 0;
			foreach (var e in table.Drops)
				total += e.Chance;

			int roll = Random.Range(0, total);
			int accum = 0;

			foreach (var e in table.Drops)
			{
				accum += e.Chance;
				if (roll < accum)
					return e;
			}

			return table.Drops[0];
		}

		private static string RollRarity(int[] weights)
		{
			int total = 0;
			foreach (var w in weights)
				total += w;

			int roll = Random.Range(0, total);
			int accum = 0;

			for (int i = 0; i < weights.Length; i++)
			{
				accum += weights[i];
				if (roll < accum)
					return RarityIndexToName(i);
			}

			return "Common";
		}

		private static string RarityIndexToName(int idx)
		{
			return idx switch
			{
				0 => "Common",
				1 => "Uncommon",
				2 => "Rare",
				3 => "Epic",
				4 => "Legendary",
				_ => "Common"
			};
		}
	}
}


// ---------- HullLoader.cs ----------
using System;
using System.IO;
using UnityEngine;

namespace Ships
{
	using System.IO;
	using UnityEngine;
	using System.Collections.Generic;

	public static class HullLoader
	{
		private static readonly string HullsPath =
			Path.Combine(Application.streamingAssetsPath, "Configs/Hulls");

		public static HullModel Load(string id)
		{
			var file = Path.Combine(HullsPath, id + ".json");
			var json = File.ReadAllText(file);
			return JsonUtility.FromJson<HullModel>(json);
		}

	}
}


// ---------- HullModel.cs ----------
using System.Collections.Generic;

namespace Ships
{
	using System;
	using System.Collections.Generic;

	[Serializable]
	public class HullModel
	{
		public string id;
		public string name;
		public int cost;

		public StatContainer stats;
		public List<ShieldModel> shields;
		public List<WeaponSlotModel> weaponSlots;
		public List<EffectModel> uniqueEffects;
		public List<LevelModel> leveling;
	}
	[Serializable]
	public class StatContainer
	{
		public float HitPoint;
		public float Armor;
		public float Shield;
		public float ShieldRegen;
		public float MoveSpeed;
		public float TurnSpeed;
		public float Acceleration;
		public float BrakePower;
	}
	
	[Serializable]
	public class EffectModel
	{
		public string id;
		public float value;
	}
	
	[Serializable]
	public class LevelModel
	{
		public int level;
		public int xpRequired;
	}
	
	[Serializable]
	public class ShieldModel
	{
		public string id;
		public float value;
		public float restoreTime;
		public float regeneration;
	}

	[Serializable]
	public class WeaponSlotModel
	{
		public string id;
		public string size;
		public float rotationLimitDeg;
	}

}


// ---------- InventoryItem.cs ----------
using System;

namespace Ships
{
	[Serializable]
	public class InventoryItem
	{
		public string ItemId;          // уникальный ID предмета
		public string TemplateId;      // weapon_p_small_bolter_1.json
		public string EquippedOnFitId; // фит, на котором установлен
		public int EquippedSlotIndex = -1;

		public bool IsEquipped => !string.IsNullOrEmpty(EquippedOnFitId);
	}
}


// ---------- InventoryView.cs ----------
using System;
using System.Collections.Generic;

namespace Ships
{
	public class InventoryView
	{
		private MetaState _state;
		public PlayerInventoryModel GetInventory() => _state.InventoryModel;
		// в какой слот сейчас ставим предмет
		private string _currentSlotId;
		private bool _currentIsWeapon;

		public void Init(MetaState state)
		{
			_state = state;
		}

		/// <summary>
		/// ShipFitView сообщает, что пользователь кликнул слот
		/// и теперь выбрать предмет нужно "в этот слот".
		/// </summary>
		public void BeginInstallToSlot(string slotId, bool isWeaponSlot)
		{
			_currentSlotId = slotId;
			_currentIsWeapon = isWeaponSlot;

			// тут можно сделать фильтрацию по типу/размеру, а пока просто обновим список
			GameEvent.InventoryUpdated(_state.InventoryModel);
		}

		public void SelectItem(InventoryItem item)
		{
			GameEvent.ItemSelected(item);
		}

		/// <summary>
		/// Вызывается из InventoryVisual, когда игрок кликает по предмету.
		/// </summary>
		public void InstallFromInventory(InventoryItem item)
		{
			if (string.IsNullOrEmpty(_currentSlotId))
				return;

			int slotIndex = int.Parse(_currentSlotId);

			MetaController.Instance.ShipFitView.EquipItemToSlot(
				_state.Fit.ShipId,
				slotIndex,
				item.ItemId,
				_currentIsWeapon
			);

			GameEvent.InventoryUpdated(_state.InventoryModel);
		}

		public void Open()
		{
		}
	}
}


// ---------- MetaBattleBridge.cs ----------
namespace Ships
{
	public static class MetaBattleBridge
	{
		public static MetaState LastFit;

		public static void LoadFit(MetaState state)
		{
			LastFit = state;
		}
	}

}


// ---------- MetaController.cs ----------
using Ships.Ships;

namespace Ships
{
	using UnityEngine;

	public class MetaController : MonoBehaviour
	{
		public static MetaController Instance;

		public MetaState State { get; private set; }

		[SerializeField] private MetaVisual _metaVisual;

		private ShipFitView _shipFitView;
		private InventoryView _inventoryView;
		public ShipFitView ShipFitView => _shipFitView;

		private void Awake()
		{
			if (!Instance)
				Instance = this;
			else
				Destroy(gameObject);
			State = MetaSaveSystem.Load();

			_inventoryView = new InventoryView();
			_shipFitView = new ShipFitView();

			_inventoryView.Init(State);
			_shipFitView.Init(State, _inventoryView);
			
			if (State.InventoryModel.InventoryUniqueItems.Count == 0)
			{
				GiveStarterItems();
				MetaSaveSystem.Save(State);
			}

			_metaVisual.ShipFitVisual.Init(_shipFitView);
			_metaVisual.InventoryVisual.Init(_inventoryView);
		}
		private void GiveStarterItems()
		{
			var w = ItemGenerator.GenerateWeapon("weapon_p_small_bolter_1.json", "Common");

			State.InventoryModel.InventoryUniqueItems.Add(new InventoryItem
			{
				ItemId = w.ItemId,
				TemplateId = w.TemplateId
			});
		}
	}
}


// ---------- MetaSaveSystem.cs ----------
using System.IO;
using Ships.Ships;
using UnityEngine;

namespace Ships
{
	public static class MetaSaveSystem
	{
		private static readonly string _path = 
			Path.Combine(Application.persistentDataPath, "meta.json");

		public static void Save(MetaState state)
		{
			var json = JsonUtility.ToJson(state, true);
			File.WriteAllText(_path, json);
		}

		public static MetaState Load()
		{
			if (!File.Exists(_path))
				return new MetaState();

			var json = File.ReadAllText(_path);
			var meta = JsonUtility.FromJson<MetaState>(json);
			LoadGeneratedItems(meta);
			return meta;
		}
		private static void LoadGeneratedItems(MetaState state)
		{
			string folder = ItemGenerator.OutputPath;
			if (!Directory.Exists(folder))
				return;

			foreach (var file in Directory.GetFiles(folder, "*.json"))
			{
				var json = File.ReadAllText(file);
				var gen = JsonUtility.FromJson<GeneratedWeaponItem>(json);

				state.InventoryModel.InventoryUniqueItems.Add(new InventoryItem
				{
					ItemId = gen.ItemId,
					TemplateId = gen.TemplateId
				});
			}
		}
	}
}


// ---------- MetaState.cs ----------
using System;
using System.Collections.Generic;

namespace Ships
{
	[Serializable]
	public class MetaState
	{
		public string SelectedShipId;
		public ShipFitModel Fit = new ShipFitModel();
		public List<ShipFitModel> PlayerShipFits = new ();
		public PlayerInventoryModel InventoryModel = new PlayerInventoryModel();
	}

	[System.Serializable]
	public sealed class PlayerInventoryModel
	{
		public List<InventoryItem> InventoryUniqueItems = new ();
		public List<InventoryItem> InventoryStackItems = new ();
	}
}


// ---------- ShipFitModel.cs ----------
using System;
using System.Collections.Generic;

namespace Ships
{
	[Serializable]
	public class ShipFitModel
	{
		public string ShipId;
		public List<SelectedShipWeapon> SelectedShipWeapons = new ();
		public List<SelectedHullModule> SelectedHullModules = new ();
		public List<SelectedWeaponModule> SelectedWeaponModules = new ();
		public List<SelectedActiveModule> SelectedActiveModules = new ();
		
		[System.Serializable]
		public class SelectedShipWeapon
		{
			public string Id;
			public int SlotIndex;
		}
		[System.Serializable]
		public class SelectedHullModule
		{
			public string Id;
			public int SlotIndex;
		}
		[System.Serializable]
		public class SelectedWeaponModule
		{
			public string Id;
			public int SlotIndex;
		}
		[System.Serializable]
		public class SelectedActiveModule
		{
			public string Id;
			public int SlotIndex;
		}
		
	}

}


// ---------- ShipFitView.cs ----------
using System;

namespace Ships
{
	public class ShipFitView
	{
		private MetaState _state;
		private InventoryView _inventory;

		// слот поменялся (для визуалов)
		public event Action<string, bool> OnSlotChanged; // slotId, isWeapon

		public void Init(MetaState state, InventoryView inventory)
		{
			_state = state;
			_inventory = inventory;
		}

		/// <summary>
		/// Вызывается визуалом слота при клике.
		/// </summary>
		public void OnSlotClicked(string slotId, bool isWeaponSlot)
		{
			// вместо старого InventoryView.ShowInstallMenu(...)
			// просто говорим InventoryView: "мы собираемся ставить в этот слот"
			_inventory.BeginInstallToSlot(slotId, isWeaponSlot);
		}
		public void UnequipItem(InventoryItem item)
		{
			if (item == null || !item.IsEquipped)
				return;

			var fit = _state.Fit;

			// убрать из фита
			fit.SelectedShipWeapons.RemoveAll(x => x.Id == item.ItemId);
			fit.SelectedHullModules.RemoveAll(x => x.Id == item.ItemId);
			fit.SelectedWeaponModules.RemoveAll(x => x.Id == item.ItemId);
			fit.SelectedActiveModules.RemoveAll(x => x.Id == item.ItemId);

			// снять флаг
			item.EquippedOnFitId = null;
			item.EquippedSlotIndex = -1;
		}
		public void EquipItemToSlot(string fitId, int slotIndex, string itemId, bool isWeapon)
		{
			var inv = _state.InventoryModel;

			// 1. получаем предмет
			var item = InventoryUtils.FindByItemId(inv, itemId);

			// 2. если предмет на другом фите → снимаем
			if (item.IsEquipped && item.EquippedOnFitId != fitId)
			{
				UnequipItem(item);
			}

			// 3. если в слоте уже что-то есть → снять
			if (isWeapon)
			{
				var existing = _state.Fit.SelectedShipWeapons.Find(x => x.SlotIndex == slotIndex);
				if (existing != null)
					UnequipItem(InventoryUtils.FindByItemId(inv, existing.Id));

				_state.Fit.SelectedShipWeapons.RemoveAll(x => x.SlotIndex == slotIndex);
				_state.Fit.SelectedShipWeapons.Add(new ShipFitModel.SelectedShipWeapon
				{
					Id = item.ItemId,
					SlotIndex = slotIndex
				});
			}

			// 4. помечаем предмет
			item.EquippedOnFitId = fitId;
			item.EquippedSlotIndex = slotIndex;

			// 5. UI
			OnSlotChanged?.Invoke(slotIndex.ToString(), isWeapon);
			MetaSaveSystem.Save(_state);
		}

		/// <summary>
		/// Логика установки предмета в слот (если хочешь держать это во View).
		/// </summary>
		public void InstallItem(string slotId, string itemId, bool isWeapon)
		{
			//if (isWeapon)
				//_state.Fit.SetWeapon(slotId, itemId);
			//else
				//_state.Fit.SetModule(slotId, itemId);

			OnSlotChanged?.Invoke(slotId, isWeapon);
		}
	}
}


// ---------- DummyTarget.cs ----------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Ships.Mobs
{
	public class DummyTarget : ShipBase
	{
		private void Start()
		{
			ShipStats = new Stats();
			ShipStats.AddStat(new Stat(StatType.HitPoint, 100));
			ShipStats.AddStat(new Stat(StatType.Shield, 50));
			ShipStats.AddStat(new Stat(StatType.MoveSpeed, 10));
			Init();
			LoadShipFromPrefab();
		}
	}
}


// ---------- ActiveEffectVisual.cs ----------
namespace Ships
{
	[System.Serializable]
	public class ActiveEffectVisual
	{
		public string EffectName;
		public float Duration;
		public float Remaining;

		public ActiveEffectVisual(string name, float duration)
		{
			EffectName = name;
			Duration = duration;
			Remaining = duration;
		}
	}

}


// ---------- ITargetable.cs ----------
using UnityEngine;

namespace Ships
{
	public interface ITargetable : IStatsProvider
	{
		Transform Transform { get; }
		bool IsAlive { get; }
		TargetSize Size { get; }
		Vector2 Velocity { get; }
		TeamMask Team { get; }
		void TakeDamage(CalculatedDamage calculatedDamage);
	}

}


// ---------- PlayerShip.cs ----------
using System.Collections.Generic;

namespace Ships
{
	public class PlayerShip : ShipBase
	{
		
		private void Awake()
		{
			LoadShipFromConfig("hull_test_frigate");
			Init();
		}
		
	}
}


// ---------- PlayerShipMovement.cs ----------
using UnityEngine;

namespace Ships
{
    public class PlayerShipMovement : MonoBehaviour
    {
        [Header("Runtime")]
        public Vector2 velocity;

        private Vector2 _desiredDirection;

        private ShipBase _ship;
        private PlayerInputSystem _hw;
        private PlayerInputUI _ui;

        // ---------------------------
        // Tuneable behaviour
        // ---------------------------
        [Header("Turning Behaviour")]
        [SerializeField] private float gentleTurnAngle = 15f;   // малый угол — корректировка без потери скорости
        [SerializeField] private float mediumTurnAngle = 45f;   // средний угол — немного тормозим
        //[SerializeField] private float rotationSpeed = 180f;    // скорость поворота корпуса (deg/sec)
        [SerializeField] private float velocityAlignRate = 8f;  // как быстро velocity догоняет forward

        private void Awake()
        {
            _ship = GetComponent<ShipBase>();
            _hw = FindObjectOfType<PlayerInputSystem>();
            _ui = FindObjectOfType<PlayerInputUI>();
        }

        private void Update()
        {
            ReadInput();
            HandleRotation();
            HandleMovement();
        }

        // ============================================================
        // INPUT
        // ============================================================
        private void ReadInput()
        {
            var hwDir = _hw != null ? _hw.Steering : Vector2.zero;
            var uiDir = _ui != null ? _ui.SteeringUI : Vector2.zero;

            var sum = hwDir + uiDir;

            if (sum.sqrMagnitude > 0.001f)
                _desiredDirection = sum.normalized;
            else
                _desiredDirection = Vector2.zero;
        }

        // ============================================================
        // ROTATION (Forward главный)
        // ============================================================
        private void HandleRotation()
        {
            if (_desiredDirection.sqrMagnitude < 0.001f)
                return;

            var targetAngle = Mathf.Atan2(_desiredDirection.y, _desiredDirection.x) * Mathf.Rad2Deg - 90f;
            var currentAngle = transform.eulerAngles.z;

            transform.rotation = Quaternion.RotateTowards(
                Quaternion.Euler(0, 0, currentAngle),
                Quaternion.Euler(0, 0, targetAngle),
                _ship.GetStat(StatType.TurnSpeed).Current * Time.deltaTime
            );
        }

        // ============================================================
        // MOVEMENT
        // ============================================================
        private void HandleMovement()
        {
            var maxSpeed   = _ship.GetStat(StatType.MoveSpeed).Current;
            var accel      = _ship.GetStat(StatType.Acceleration).Current;
            var brakePower = _ship.GetStat(StatType.BrakePower).Current;

            var currentSpeed = velocity.magnitude;
            var forward = transform.up;
            var hasInput = _desiredDirection.sqrMagnitude > 0.001f;

            // -------------------------------
            // Determine angle change
            // -------------------------------
            float angle = hasInput
                ? Vector2.Angle(forward, _desiredDirection)
                : 0f;

            float targetSpeed;

            // ============================================================
            // CASE 1 — малый угол → не тормозим, только корректируем
            // ============================================================
            if (hasInput && angle < gentleTurnAngle)
            {
                targetSpeed = maxSpeed;
            }
            // ============================================================
            // CASE 2 — средний угол → немного тормозим
            // ============================================================
            else if (hasInput && angle < mediumTurnAngle)
            {
                targetSpeed = Mathf.Lerp(currentSpeed, maxSpeed, 0.5f);
            }
            // ============================================================
            // CASE 3 — резкий манёвр → серьёзное торможение
            // ============================================================
            else if (hasInput)
            {
                targetSpeed = 0f; // почти остановка перед разворотом
            }
            else
            {
                // игрок отпустил управление → тормоз
                targetSpeed = 0f;
            }

            // -------------------------------
            // Accelerate / brake toward targetSpeed
            // -------------------------------
            if (targetSpeed > currentSpeed)
            {
                currentSpeed = Mathf.MoveTowards(
                    currentSpeed,
                    targetSpeed,
                    accel * Time.deltaTime
                );
            }
            else
            {
                currentSpeed = Mathf.MoveTowards(
                    currentSpeed,
                    targetSpeed,
                    brakePower * Time.deltaTime
                );
            }

            // -------------------------------
            // Velocity follows forward
            // -------------------------------
            if (velocity.sqrMagnitude > 0.001f)
            {
                var newDir = Vector2.Lerp(
                    velocity.normalized,
                    forward,
                    velocityAlignRate * Time.deltaTime
                ).normalized;

                velocity = newDir * currentSpeed;
            }
            else
            {
                velocity = forward * currentSpeed;
            }

            // -------------------------------
            // Apply movement
            // -------------------------------
            transform.position += (Vector3)velocity * Time.deltaTime;

            if (Battle.Instance != null)
            {
                var clamped = Battle.Instance.ClampPosition(transform.position);
                transform.position = clamped;

                if ((Vector2)transform.position != clamped)
                    velocity = Vector2.zero;
            }
        }
    }
}



// ---------- ShipBase.cs ----------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Ships
{
	public abstract class ShipBase : MonoBehaviour, ITargetable
	{
		public ShipVisual _visual;
		public SideType SideType;
		[SerializeField] private TeamMask _team;
		public Stats ShipStats;
		[SerializeField] private TargetSize size = TargetSize.Medium;
		public List<StatVisual> StatVisuals = new();
		public WeaponController WeaponController;

		public List<ShieldSector> ShieldSectors = new();
		public HashSet<string> RunningDotEffects = new();
		public Transform Transform => transform;
		public TargetSize Size => size;

		private Vector3 _lastPos;
		private Vector2 _velocity;
		public Vector2 Velocity => _velocity;

		public TeamMask Team => _team;

		public bool IsAlive
		{
			get
			{
				if (ShipStats.TryGetStat(StatType.HitPoint, out var hp))
					return hp.Current > 0;
				return true;
			}
		}

		public virtual void LoadShipFromConfig(string fileName)
		{
			ShipStats = new Stats();
			var data = HullLoader.Load(fileName);
			var fields = typeof(StatContainer).GetFields(
				BindingFlags.Public | BindingFlags.Instance);

			foreach (var f in fields)
			{
				var fieldName = f.Name;
				if (!Enum.TryParse(fieldName, out StatType statType))
					continue;
				var value = (float)f.GetValue(data.stats);
				ShipStats.AddStat(new Stat(statType, value));
			}
			
			if (TryGetComponent<ShieldController>(out var controller))
			{
				foreach (var sector in ShieldSectors)
				{
					var modelFromSide = data.shields.Find(x =>
					{
						return Enum.TryParse<ShieldSide>(x.id, true, out var parsed) 
						       && parsed == sector.Side;
					});

					sector.InitFromConfig(
						hp: modelFromSide.value,
						regen: modelFromSide.regeneration,
						restoreDelay: modelFromSide.restoreTime
					);

					controller.AddSector(sector);
				}
				
			}
		}
		
		public void LoadShipFromPrefab()
		{
			if (TryGetComponent<ShieldController>(out var controller))
			{
				foreach (var sector in ShieldSectors)
				{
					sector.InitFromPrefab();
					controller.AddSector(sector);
				}
			}
		}
		

		// -------------------------------
		//  STACKABLE EFFECT SYSTEM
		// -------------------------------
		public class ActiveEffectInstance
		{
			public string EffectId;
			public int Stacks;
			public float Remaining;
			public float Duration;

			public ActiveEffectInstance(string id, float duration)
			{
				EffectId = id;
				Duration = duration;
				Remaining = duration;
				Stacks = 1;
			}
		}

		public List<ActiveEffectInstance> ActiveEffects = new();


		// ============================================================
		// INIT
		// ============================================================

		public void Init()
		{
			_team = SideType switch
			{
				SideType.Player => TeamMask.Player,
				SideType.Enemy => TeamMask.Enemy,
				SideType.Ally => TeamMask.Ally,
				_ => TeamMask.Neutral
			};

			if (_visual != null)
			{
				_visual.Unload();
				_visual.Load();
			}
			else
			{
				_visual = new ShipVisual();
				_visual.Load();
			}

			WeaponController.Init(SideType);
			Battle.Instance.AllShips.Add(this);
			StartCoroutine(TickEffects());
			// отправляем визуализаторам данные статов
			StatVisuals.Clear();
			foreach (var kvp in ShipStats.All)
			{
				StatVisuals.Add(new StatVisual { Name = kvp.Key });
			}

			_lastPos = transform.position;
		}
		


		// ============================================================
		// DAMAGE → EFFECTS
		// ============================================================

		public void TakeDamage(CalculatedDamage calc)
		{
			if (calc.FinalDamage > 0)
			{
				if (TryGetStat(StatType.HitPoint, out var hp))
					hp.AddToCurrent(-calc.FinalDamage);
			}

			if (calc.SourceWeapon?.Model?.Effects != null)
			{
				foreach (var effect in calc.SourceWeapon.Model.Effects)
					effect.Apply(this, calc.FinalDamage, calc.SourceWeapon);
			}
		}


		// ============================================================
		// STACKABLE EFFECT API
		// ============================================================

		public ActiveEffectInstance GetEffect(string effectId)
		{
			return ActiveEffects.FirstOrDefault(e => e.EffectId == effectId);
		}

		public void AddOrStackEffect(IStackableEffect effect, float duration)
		{
			var inst = GetEffect(effect.EffectId);

			if (inst == null)
			{
				inst = new ActiveEffectInstance(effect.EffectId, duration);
				ActiveEffects.Add(inst);
			}
			else
			{
				inst.Remaining = duration;

				if (effect.CanStack)
					inst.Stacks = Mathf.Min(inst.Stacks + 1, effect.MaxStacks);
				else
					inst.Stacks = 1;
			}
		}


		// ============================================================
		// EFFECT TICK
		// ============================================================

		private IEnumerator TickEffects()
		{
			while (true)
			{
				yield return new WaitForSeconds(1f);

				// 1) Тик модификаторов статов
				ShipStats.Tick();

				// 2) Тик эффектов
				for (int i = ActiveEffects.Count - 1; i >= 0; i--)
				{
					var eff = ActiveEffects[i];
					eff.Remaining -= 1f;

					if (eff.Remaining <= 0)
						ActiveEffects.RemoveAt(i);
				}
			}
		}


		// ============================================================
		// UPDATE (velocity, stat visuals, weapons)
		// ============================================================

		private void Update()
		{
			if (!IsAlive)
			{
				if (SideType == SideType.Enemy)
					Battle.Instance.AllShips.Remove(this);

				Destroy(gameObject);
				return;
			}

			// обновить Velocity
			var pos = transform.position;
			_velocity = (pos - _lastPos) / Time.deltaTime;
			_lastPos = pos;

			// обновляем визуальное состояние статов
			foreach (var kvp in ShipStats.All)
			{
				var statType = kvp.Key;
				var stat = kvp.Value;

				foreach (var visual in StatVisuals)
				{
					if (visual.Name == statType)
					{
						visual.BaseCurrent = stat.BaseCurrent;
						visual.BaseMaximum = stat.BaseMaximum;
						visual.Current = stat.Current;
						visual.Maximum = stat.Maximum;

						visual.ModifierVisuals.Clear();
						foreach (var mod in stat.Modifiers)
						{
							visual.ModifierVisuals.Add(new StatModifierVisual
							{
								Type = mod.Type,
								Target = mod.Target,
								Periodicity = mod.Periodicity,
								Value = mod.Value,
								RemainingTicks = mod.RemainingTicks,
								SourceName = mod.Source?.ToString()
							});
						}
					}
				}
			}

			// обновление оружия
			WeaponController.OnUpdate();
		}


		// ============================================================
		// INTERFACE
		// ============================================================

		public bool TryGetStat(StatType name, out IStat stat)
		{
			bool result = ShipStats.TryGetStat(name, out var s);
			stat = s;
			return result;
		}

		public IStat GetStat(StatType name) => ShipStats.GetStat(name);
		public IEnumerable<IStat> GetAllStats() => ShipStats.All.Values;
	}
}


// ---------- ShipVisual.cs ----------
namespace Ships
{
	public sealed class ShipVisual : VisualBase
	{
		public override void Load()
		{
		
		}

		public override void Unload()
		{
			
		}
	}
}


// ---------- SideType.cs ----------
namespace Ships
{
	public enum SideType
	{
		Player,
		Enemy,
		Ally
	}
}


// ---------- TargetSize.cs ----------
namespace Ships
{
	public enum TargetSize
	{
		Small,
		Medium,
		Large
	}
}


// ---------- TeamMask.cs ----------
using System;

namespace Ships
{
	[Flags]
	public enum TeamMask
	{
		None   = 0,
		Player = 1 << 0,
		Enemy  = 1 << 1,
		Ally   = 1 << 2,
		Neutral = 1 << 3,

		All = ~0
	}
}


// ---------- VisualBase.cs ----------
namespace Ships
{
	public abstract class VisualBase : IVisual
	{
		public abstract void Load();

		public abstract void Unload();
	}
}


// ---------- WeaponController.cs ----------
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Ships
{
	[System.Serializable]
	public class WeaponController
	{
		public List<WeaponSlot> Weapons = new List<WeaponSlot>();
		
		public void Init(SideType sideType)
		{
			foreach (var weapon in Weapons)
			{
				weapon.Init(sideType);
			}
		}
		public void OnUpdate()
		{
			var ships = Battle.Instance.AllShips;

			foreach (var slot in Weapons)
			{
				if (slot?.WeaponTargeting == null)
					continue;

				slot.WeaponTargeting.UpdateTargetList(ships);
			}
		}
	}
}


// ---------- IStat.cs ----------
namespace Ships
{
	public interface IStat
	{
		StatType Name { get; }

		float BaseMaximum { get; }
		float BaseCurrent { get; }

		float Maximum { get; }
		float Current { get; }
		float Amount { get; }
		void AddModifier(StatModifier modifier);
		void RemoveModifier(StatModifier modifier);
		void RemoveModifiersFromSource(object source);

		void AddToCurrent(float delta);

		void Tick();
	}
}


// ---------- IStatsProvider.cs ----------
using System.Collections.Generic;

namespace Ships
{
	public interface IStatsProvider
	{
		bool TryGetStat(StatType name, out IStat stat);
		IStat GetStat(StatType name);
		IEnumerable<IStat> GetAllStats();
	}
}


// ---------- Stat.cs ----------
using System.Collections.Generic;

namespace Ships
{
    public sealed class Stat : IStat
    {
        public StatType Name { get; }
        public float BaseMaximum { get; private set; }
        public float BaseCurrent { get; private set; }
        public float Maximum { get; private set; }
        public float Current { get; private set; }

        public float Amount
        {
            get
            {
                if (Maximum <= 0f) 
                    return 0f;
                var n = Current / Maximum;
                if (float.IsNaN(n) || float.IsInfinity(n))
                    return 0f;
                return n;
            }
        }
        
        private readonly List<StatModifier> _modifiers = new List<StatModifier>();
        public IReadOnlyList<StatModifier> Modifiers => _modifiers;

        public Stat(StatType name, float baseMaximum, float? baseCurrent = null)
        {
            Name = name;
            BaseMaximum = baseMaximum;
            BaseCurrent = baseCurrent ?? baseMaximum;
            Maximum = BaseMaximum;
            Current = BaseCurrent;
        }

        public void SetBaseValues(float baseMaximum, float? baseCurrent = null, bool resetCurrentToFull = false)
        {
            BaseMaximum = baseMaximum;
            BaseCurrent = baseCurrent ?? BaseMaximum;
            Recalculate(resetCurrentToFull);
        }

        public void SetBaseMaximum(float baseMaximum, bool resetCurrentToFull = false)
        {
            BaseMaximum = baseMaximum;
            Recalculate(resetCurrentToFull);
        }

        public void SetBaseCurrent(float baseCurrent)
        {
            BaseCurrent = baseCurrent;
            Recalculate(false);
        }

        public void AddToCurrent(float delta)
        {
            Current += delta;
            if (Current > Maximum)
                Current = Maximum;
            if (Current < 0)
                Current = 0;
        }

        public void AddModifier(StatModifier modifier)
        {
            _modifiers.Add(modifier);
            Recalculate(false);
        }

        public void RemoveModifier(StatModifier modifier)
        {
            if (_modifiers.Remove(modifier))
            {
                Recalculate(false);
            }
        }

        public void RemoveModifiersFromSource(object source)
        {
            if (source == null)
                return;

            var changed = false;
            for (int i = _modifiers.Count - 1; i >= 0; i--)
            {
                if (_modifiers[i].Source == source)
                {
                    _modifiers.RemoveAt(i);
                    changed = true;
                }
            }

            if (changed)
            {
                Recalculate(false);
            }
        }

        public void Tick()
        {
            var changed = false;

            for (int i = _modifiers.Count - 1; i >= 0; i--)
            {
                var mod = _modifiers[i];
                if (mod.Periodicity == StatModifierPeriodicity.Timed)
                {
                    mod.RemainingTicks--;
                    if (mod.RemainingTicks <= 0)
                    {
                        _modifiers.RemoveAt(i);
                        changed = true;
                    }
                }
            }

            if (changed)
            {
                Recalculate(false);
            }
        }

        private void Recalculate(bool resetCurrentToFull)
        {
            // сохраняем прошлую пропорцию
            var previousMax = Maximum > 0 ? Maximum : BaseMaximum;
            var previousRatio = previousMax > 0 ? Current / previousMax : 1f;

            // новая максималка
            var newMaximum = ApplyModifiers(BaseMaximum, StatModifierTarget.Maximum);

            // базовое текущее (до модификаторов Current)
            var newCurrentBase = resetCurrentToFull ? newMaximum : BaseCurrent;

            // применяем модификаторы к Current (их у MoveSpeed нет)
            var hasCurrentMods = HasModifiersForTarget(StatModifierTarget.Current);
            var newCurrent = ApplyModifiers(newCurrentBase, StatModifierTarget.Current);

            // ---- ВАЖНО: выбираем поведение в зависимости от типа стата ----

            bool isResource = Name == StatType.HitPoint || 
                              Name == StatType.Shield;

            if (!hasCurrentMods)
            {
                if (resetCurrentToFull)
                {
                    newCurrent = newMaximum;
                }
                else if (isResource)
                {
                    // HP/Shield сохраняют процент
                    newCurrent = newMaximum * previousRatio;
                }
                else
                {
                    // ВСЕ ПАРАМЕТРЫ (MoveSpeed, Accel, FireRate, TurnSpeed и т.д.)
                    // ВСЕГДА возвращаются на максимум после снятия модификаторов
                    newCurrent = newMaximum;
                }
            }

            // clamp
            if (newCurrent > newMaximum) newCurrent = newMaximum;
            if (newCurrent < 0) newCurrent = 0;

            Maximum = newMaximum;
            Current = newCurrent;
        }

        private bool HasModifiersForTarget(StatModifierTarget target)
        {
            for (int i = 0; i < _modifiers.Count; i++)
            {
                if (_modifiers[i].Target == target)
                    return true;
            }

            return false;
        }

        private float ApplyModifiers(float baseValue, StatModifierTarget target)
        {
            var flatAdd = 0f;
            var percentAdd = 0f;
            var percentMult = 1f;
            var hasSet = false;
            var setValue = 0f;

            for (int i = 0; i < _modifiers.Count; i++)
            {
                var mod = _modifiers[i];
                if (mod.Target != target)
                    continue;

                switch (mod.Type)
                {
                    case StatModifierType.Flat:
                        flatAdd += mod.Value;
                        break;

                    case StatModifierType.PercentAdd:
                        percentAdd += mod.Value;
                        break;

                    case StatModifierType.PercentMult:
                        percentMult *= (1f + mod.Value);
                        break;

                    case StatModifierType.Set:
                        hasSet = true;
                        setValue = mod.Value;
                        break;
                }
            }

            var value = baseValue + flatAdd;
            value *= (1f + percentAdd);
            value *= percentMult;

            if (hasSet)
                value = setValue;

            return value;
        }
    }
}



// ---------- StatModifier.cs ----------
namespace Ships
{
	public sealed class StatModifier
	{
		public StatModifierType Type { get; }
		public StatModifierTarget Target { get; }
		public StatModifierPeriodicity Periodicity { get; }

		/// <summary>
		/// Величина модификатора:
		/// Flat: +X
		/// PercentAdd/PercentMult: X = 0.1f => +10%
		/// Set: новое значение.
		/// </summary>
		public float Value { get; }

		public int RemainingTicks { get; set; }
		public object Source { get; }

		public StatModifier(
			StatModifierType type,
			StatModifierTarget target,
			StatModifierPeriodicity periodicity,
			float value,
			int remainingTicks = 0,
			object source = null)
		{
			Type = type;
			Target = target;
			Periodicity = periodicity;
			Value = value;
			RemainingTicks = remainingTicks;
			Source = source;
		}
	}
}


// ---------- StatModifierTypes.cs ----------
namespace Ships
{
	/// <summary>
	/// Тип изменения величины.
	/// </summary>
	public enum StatModifierType
	{
		/// <summary>
		/// Плоская прибавка: value = value + X
		/// </summary>
		Flat,

		/// <summary>
		/// Суммарный процент: value = value * (1 + sum)
		/// </summary>
		PercentAdd,

		/// <summary>
		/// Мультипликативный процент: value = value * product(1 + X)
		/// </summary>
		PercentMult,

		/// <summary>
		/// Жёсткая установка: value = X
		/// </summary>
		Set
	}

	/// <summary>
	/// К какой части стата применяется модификатор.
	/// </summary>
	public enum StatModifierTarget
	{
		Current,
		Maximum
	}

	/// <summary>
	/// Периодичность действия модификатора.
	/// </summary>
	public enum StatModifierPeriodicity
	{
		/// <summary>
		/// Действует постоянно, пока явно не удалён.
		/// </summary>
		Permanent,

		/// <summary>
		/// Ограничен количеством тиков.
		/// </summary>
		Timed
	}
}


// ---------- StatModifierVisual.cs ----------
namespace Ships
{
	[System.Serializable]
	public class StatModifierVisual
	{
		public StatModifierType Type;
		public StatModifierTarget Target;
		public StatModifierPeriodicity Periodicity;
		public float Value;
		public int RemainingTicks;
		public string SourceName;
	}
}


// ---------- Stats.cs ----------
using System.Collections.Generic;
using UnityEngine;

namespace Ships
{
	public sealed class Stats
	{
		private readonly Dictionary<StatType, Stat> _stats = new Dictionary<StatType, Stat>();

		public IReadOnlyDictionary<StatType, Stat> All => _stats;

		public void AddStat(Stat stat)
		{
			_stats[stat.Name] = stat;
		}

		public bool TryGetStat(StatType name, out Stat stat)
		{
			return _stats.TryGetValue(name, out stat);
		}

		public Stat GetStat(StatType name)
		{
			_stats.TryGetValue(name, out var stat);
			return stat;
		}

		public float GetCurrent(StatType name)
		{
			if (!_stats.TryGetValue(name, out var stat))
			{
				Debug.LogWarning($"Stat {name} not found in Stats!");
				return 0f;
			}
			return stat.Current;
		}

		public float GetMaximum(StatType name)
		{
			return _stats.TryGetValue(name, out var stat) ? stat.Maximum : 0f;
		}
		
		public void Tick()
		{
			foreach (var stat in _stats.Values)
			{
				stat.Tick();
			}
		}
	}
}


// ---------- StatType.cs ----------
namespace Ships
{
	public enum StatType
	{
		// Ship
		HitPoint,
		MoveSpeed,
		TurnSpeed,
		Shield,
		ShieldRegen,
		Acceleration,
		BrakePower,
		ShieldRestoreDelay,
		BackSpeed,
		Armor,

		// Weapon
		FireRate,
		MinDamage,
		MaxDamage,
		CritChance,
		CritMultiplier,
		ProjectileSpeed,
		ArmorPierce,
		FireRange,
		Accuracy,
		AmmoCount,
		ReloadTime,

		// Resistances
		KineticResist,
		ThermalResist,
		ExplosionResist,
	}
}


// ---------- StatVisual.cs ----------
using System.Collections.Generic;

namespace Ships
{
	[System.Serializable]
	public class StatVisual
	{
		public StatType Name;
		public float BaseMaximum;
		public float BaseCurrent;
		public float Maximum;
		public float Current;

		public List<StatModifierVisual> ModifierVisuals = new List<StatModifierVisual>();
	}
}


// ---------- IOnHitEffect.cs ----------
namespace Ships
{
	public interface IOnHitEffect
	{
		void Apply(ITargetable target, float damage, WeaponBase sourceWeapon);
	}
}


// ---------- IStackableEffect.cs ----------
namespace Ships
{
	public interface IStackableEffect : IOnHitEffect
	{
		string EffectId { get; }
		bool CanStack { get; }
		int MaxStacks { get; }
	}

}


// ---------- Projectile.cs ----------
using UnityEngine;
using UnityEngine.EventSystems;

namespace Ships
{
	using UnityEngine;

	public class Projectile : MonoBehaviour
	{
		private Transform target;
		private float speed;
		private float damage;
		private float armorPierce;
		public WeaponBase SourceWeapon;
		public ShipBase Owner;
		public TeamMask HitMask;
		[SerializeField] private Vector2 moveDir;

		public void Init(Vector2 direction, float dmg, float spd, float ap, WeaponBase source)
		{
			damage = dmg;
			speed = spd;
			armorPierce = ap;
			SourceWeapon = source;
			moveDir = direction.normalized;
			HitMask = SourceWeapon.Slot.HitMask;
		}

		void Update()
		{
			transform.position += (Vector3)(moveDir * speed * Time.deltaTime);
		}

		public float Damage => damage;

		public void DestroySelf()
		{
			Destroy(gameObject);
		}
		private void OnTriggerEnter2D(Collider2D other)
		{
			if (!other.TryGetComponent<ITargetable>(out var targetable))
				return;
			if (!HitRules.CanHit(HitMask, targetable.Team))
				return;
		
			var calc = DamageCalculator.CalculateHit(
				projectileDamage: damage,
				armorPierce: armorPierce,
				hitPoint: transform.position,
				sourceWeapon: SourceWeapon,
				target: targetable,
				wasShieldHit: false
			);
			
			GameEvent.TakeDamage(calc);
			targetable.TakeDamage(calc);
			Destroy(gameObject);
		}
	}

}


// ---------- ProjectileWeapon.cs ----------
using System;

namespace Ships
{
	using UnityEngine;

	public class ProjectileWeapon : WeaponBase
	{
		public Projectile ProjectilePrefab;
		private bool IsInit;

		protected override void Shoot(Transform target)
		{
			float damage = RollDamage();
			float speed = Model.Stats.GetStat(StatType.ProjectileSpeed).Current;

			if (speed <= 0.01f)
			{
				DoInstantHit(target, damage);
			}
			else
			{
				var proj = Instantiate(ProjectilePrefab, FirePoint.position, FirePoint.rotation);
				proj.Init((Vector2)FirePoint.right, damage, speed, Model.Stats.GetStat(StatType.ArmorPierce).Current, this);
			}
		}

		private void DoInstantHit(Transform target, float dmg)
		{
			if (target.TryGetComponent<ITargetable>(out var t))
			{
				if (t.TryGetStat(StatType.HitPoint, out var hp))
					hp.AddToCurrent(-dmg);

				foreach (var effect in Model.Effects)
					effect.Apply(t, dmg, this);
			}
		}
	}
}


// ---------- WeaponBase.cs ----------
using System;
using UnityEngine;

namespace Ships
{
	using UnityEngine;

	public abstract class WeaponBase : MonoBehaviour
	{
		private float _nextFireTime;

		public WeaponSlot Slot;
		public WeaponModel Model;
		public Transform FirePoint;
		private int _ammo;
		private bool _isReloading;
		private float _reloadFinishTime;
		
		public void Init(WeaponSlot slot, Stats stats)
		{
			Model = new WeaponModel();
			Model.InjectStat(stats);
			Slot = slot;
			_ammo = GetMaxAmmo(); 
		}

		public void TickWeapon(Transform target)
		{
			if (target == null || Model == null)
				return;

			if (_isReloading)
			{
				if (Time.time >= _reloadFinishTime)
				{
					_isReloading = false;
					_ammo = GetMaxAmmo();
				}
				return;
			}

			if (_ammo <= 0)
			{
				StartReload();
				return;
			}

			if (Time.time < _nextFireTime)
				return;

			Shoot(target);

			_ammo--;
			_nextFireTime = Time.time + 1f / Model.Stats.GetStat(StatType.FireRate).Current;

			if (_ammo <= 0)
				StartReload();
		}
		private int GetMaxAmmo()
		{
			return Mathf.RoundToInt(Model.Stats.GetStat(StatType.AmmoCount).Maximum);
		}
		private void StartReload()
		{
			_isReloading = true;
			_reloadFinishTime = Time.time + Model.Stats.GetStat(StatType.ReloadTime).Maximum;
		}
		
		public void TickWeaponPosition(Vector2 aimPoint)
		{
			if (Model == null)
				return;

			Vector2 dir = aimPoint - (Vector2)Slot.transform.position;
			RotateToTarget(dir);
		}

		protected virtual void RotateToTarget(Vector2 direction)
		{
			if (!Slot.IsTurret)
				return;

			float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
			Quaternion rot = Quaternion.Euler(0, 0, angle);
			transform.rotation = Quaternion.Lerp(transform.rotation, rot, Time.deltaTime * 10f);
		}

		protected abstract void Shoot(Transform target);

		protected float RollDamage()
		{
			float dmg = Random.Range(Model.Stats.GetStat(StatType.MinDamage).Current, Model.Stats.GetStat(StatType.MaxDamage).Current);

			if (Random.value < Model.Stats.GetStat(StatType.CritChance).Current)
				dmg *= Model.Stats.GetStat(StatType.CritMultiplier).Current;

			return dmg;
		}
	}

}



// ---------- WeaponModel.cs ----------
using System.Collections.Generic;

namespace Ships
{
	public class WeaponModel
	{
		public Stats Stats { get; set; }
		private readonly List<IOnHitEffect> _effects = new();

		public void AddEffect(IOnHitEffect effect) => _effects.Add(effect);
		public IReadOnlyList<IOnHitEffect> Effects => _effects;

		public WeaponModel(Stats stats = null)
		{
			Stats = stats;
		}

		public void InjectStat(Stats newStats)
		{
			Stats = newStats;
		}
		
	}



}


// ---------- WeaponSize.cs ----------
namespace Ships
{
	public enum WeaponSize
	{
		S,
		M,
		L
	}
}


// ---------- WeaponSlot.cs ----------
using System;

namespace Ships
{
	using UnityEngine;

	public class WeaponSlot : MonoBehaviour
	{
		public float AllowedAngle = 45f;
		public bool IsTurret = false;
		public WeaponBase MountedWeapon;
		public WeaponTargeting WeaponTargeting;
		public SideType Side;
		public TeamMask HitMask;
		public WeaponSize SlotSize;

		public void Init(SideType sideType)
		{
			Side = sideType;

			HitMask = sideType switch
			{
				SideType.Player => TeamMask.Enemy,
				SideType.Enemy => TeamMask.Player,
				SideType.Ally => TeamMask.Enemy | TeamMask.Player, 
				_ => TeamMask.All
			};

			if (transform.childCount > 0)
			{
				MountedWeapon = transform.GetComponentInChildren<WeaponBase>();
				WeaponTargeting = transform.GetComponentInChildren<WeaponTargeting>();
			}

			if (MountedWeapon)
			{
				Stats stats = new Stats();
				stats.AddStat(new Stat(StatType.FireRange, 5));
				stats.AddStat(new Stat(StatType.FireRate, 3f));
				stats.AddStat(new Stat(StatType.ProjectileSpeed, 3));
				stats.AddStat(new Stat(StatType.MinDamage, 5));
				stats.AddStat(new Stat(StatType.MaxDamage, 10));
				stats.AddStat(new Stat(StatType.Accuracy, 0.05f));
				stats.AddStat(new Stat(StatType.CritChance, 0.1f));
				stats.AddStat(new Stat(StatType.CritMultiplier, 1.2f));
				stats.AddStat(new Stat(StatType.AmmoCount, 10));
				stats.AddStat(new Stat(StatType.ReloadTime, 5f));
				stats.AddStat(new Stat(StatType.ArmorPierce, 0f));
				MountedWeapon.Init(this, stats);
			}
				
		}

		public bool IsTargetWithinSector(Vector2 dir)
		{
			Vector2 forward = transform.right;
			var angle = Vector2.Angle(forward, dir);
			return angle <= AllowedAngle;
		}
	}
}


// ---------- WeaponTargeting.cs ----------
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

namespace Ships
{
    public class WeaponTargeting : MonoBehaviour
    {
        public WeaponBase Weapon;
        public WeaponSlot Slot;

        public TargetSize PriorityType = TargetSize.Small;

        private readonly List<ITargetable> allTargets = new();
        private ITargetable currentTarget;
        private const float MaxSpreadAngle = 25f;

        private void Start()
        {
            if (!Slot)
                Slot = GetComponentInParent<WeaponSlot>();
        }

        // Вызывается WeaponController каждый кадр
        public void UpdateTargetList(IEnumerable<ITargetable> targets)
        {
            allTargets.Clear();

            foreach (var t in targets)
            {
                // 1) жив ли?
                if (!t.IsAlive) 
                    continue;

                // 2) принадлежит ли к той команде, по которой можно стрелять?
                if (!HitRules.CanHit(Slot.HitMask, (t as ShipBase).Team))
                    continue;

                allTargets.Add(t);
            }
        }

        private void Update()
        {
            if (Slot == null || Weapon == null)
                return;

            SelectTargetIfNeeded();

            if (currentTarget == null)
                return;

            Vector2 aim = GetAimPoint(currentTarget);

            Weapon.TickWeaponPosition(aim);
            Weapon.TickWeapon(currentTarget.Transform);
        }

        private void SelectTargetIfNeeded()
        {
            if (currentTarget == null ||
                !currentTarget.IsAlive ||
                !IsTargetInRange(currentTarget) ||
                !IsTargetInSector(currentTarget))
            {
                currentTarget = FindBestTarget();
            }
        }

        private ITargetable FindBestTarget()
        {
            Vector2 pos = Slot.transform.position;

            var inRange = allTargets
                .Where(t => IsTargetInRange(t))
                .Where(t => IsTargetInSector(t))
                .ToList();

            if (inRange.Count == 0)
                return null;

            // Сначала по приоритетному размеру
            var priority = inRange
                .Where(t => t.Size == PriorityType)
                .OrderBy(t => Vector2.Distance(pos, t.Transform.position))
                .FirstOrDefault();

            if (priority != null)
                return priority;

            // Иначе ближайшая цель
            return inRange
                .OrderBy(t => Vector2.Distance(pos, t.Transform.position))
                .FirstOrDefault();
        }

        private bool IsTargetInRange(ITargetable t)
        {
            float dist = Vector2.Distance(Slot.transform.position, t.Transform.position);
            return dist <= Weapon.Model.Stats.GetStat(StatType.FireRange).Current;
        }

        private bool IsTargetInSector(ITargetable t)
        {
            Vector2 dir = (t.Transform.position - Slot.transform.position).normalized;
            return Slot.IsTargetWithinSector(dir);
        }

        private Vector2 GetAimPoint(ITargetable t)
        {
            Vector2 pos = Slot.transform.position;
            Vector2 targetPos = t.Transform.position;
            Vector2 vel = t.Velocity;

            float speed = Weapon.Model.Stats.GetStat(StatType.ProjectileSpeed).Current;
            Vector2 dir;

            if (speed > 0.01f)
            {
                float dist = Vector2.Distance(pos, targetPos);
                float time = dist / speed;

                Vector2 predicted = targetPos + vel * time;
                dir = (predicted - pos).normalized;
            }
            else
            {
                dir = (targetPos - pos).normalized;
            }

            dir = ApplyAccuracy(dir);

            return pos + dir * 100f;
        }

        private Vector2 ApplyAccuracy(Vector2 dir)
        {
            float acc = Weapon.Model.Stats.GetStat(StatType.Accuracy).Current; // 0..1
            float spread = (1f - acc) * MaxSpreadAngle;

            if (spread <= 0.01f)
                return dir;

            float angle = UnityEngine.Random.Range(-spread, spread) * Mathf.Deg2Rad;

            float cos = Mathf.Cos(angle);
            float sin = Mathf.Sin(angle);

            return new Vector2(
                dir.x * cos - dir.y * sin,
                dir.x * sin + dir.y * cos
            );
        }
    }
}



// ---------- ShieldController.cs ----------
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.EventSystems;

namespace Ships
{
    public class ShieldController : MonoBehaviour
    {
        public List<ShieldSector> Sectors = new();
        public List<ShieldSectorVisual> Visuals = new();
        public ShipBase Ship;

        private void Awake()
        {
            Ship = GetComponent<ShipBase>();
            StartCoroutine(Update1Sec());
        }

        private IEnumerator Update1Sec()
        {
            while (gameObject.activeSelf)
            {
                yield return new WaitForSeconds(1f);
                foreach (var s in Sectors)
                    s.Tick();
            }
        }
        private void Update()
        {
            UpdateVisuals();
        }

        public void AddSector(ShieldSector sector)
        {
            Sectors.Add(sector);
            RegisterVisual(sector);
        }

        public void RegisterVisual(ShieldSector sector)
        {
            sector.Visual.Init();
            sector.Visual.SetSectorAngles(sector.StartAngle, sector.EndAngle);
            sector.Visual.SetCharge(sector.ShieldHP.Current / sector.ShieldHP.Maximum);
        }
        

        public void OnShieldHit(ShieldSide side, CalculatedDamage calculatedDamage)
        {
            var sector = Sectors.FirstOrDefault(s => s.Side == side);

            // если сектора нет — прямой урон
            /*
            if (sector == null)
            {
                Ship.TakeDamage(proj.Damage, hitPoint, proj.SourceWeapon);
                return;
            }
            */

            float dmg = calculatedDamage.FinalDamage;

            // Уменьшаем HP щита
            float leftover = sector.Absorb(dmg);

            // визуал
            var vis = sector.Visual;
            vis.Hit(calculatedDamage.HitPoint);
            GameEvent.UiUpdate();
        }
        

        private void UpdateVisuals()
        {
            foreach (var se in Sectors)
            {
                var t = se.ShieldHP.Current / se.ShieldHP.Maximum;
                se.Visual.SetCharge(t);
            }
        }
    }
}



// ---------- ShieldHitbox.cs ----------
using UnityEngine;

namespace Ships
{
	public class ShieldHitbox : MonoBehaviour
	{
		public ShieldSide Side;
		public ShieldController Controller;

		private void OnTriggerEnter2D(Collider2D other)
		{
			if (!other.TryGetComponent<Projectile>(out var proj))
				return;

			if (!HitRules.CanHit(proj.HitMask, Controller.Ship.Team))
				return;

			Vector2 hitPoint = proj.transform.position;
			
			Stat s;
			proj.SourceWeapon.Model.Stats.TryGetStat(StatType.ArmorPierce, out s);
			var calc = DamageCalculator.CalculateHit(
				projectileDamage: proj.Damage,
				armorPierce:  s?.Current ?? 0,
				hitPoint:     hitPoint,
				sourceWeapon: proj.SourceWeapon,
				target:       Controller.Ship,
				wasShieldHit: true
			);

			GameEvent.TakeDamage(calc);
			Controller.OnShieldHit(Side, calc); 
			proj.DestroySelf();
		}
	}
}


// ---------- ShieldSector.cs ----------
using UnityEngine;

namespace Ships
{
	[System.Serializable]
	public class ShieldSector
	{
		public ShieldSide Side;

		public float StartAngle;
		public float EndAngle;
		public float MaxHP;
		public float Regen;
		public float RestoreDelayTime;
		public Stat ShieldHP;
		public Stat ShieldRegen;
		public Stat RestoreDelay;
		public Collider2D Collider;
		public bool IsRestoring;
		public float CurrentRestoreTime;
		public float DamageResist = 0f;
		public ShieldSectorVisual Visual;
		public float CurrentHp;// 0.2 = 20%

		public void InitFromPrefab()
		{
			ShieldHP = new Stat(StatType.Shield, MaxHP);
			ShieldRegen = new Stat(StatType.ShieldRegen, Regen);
			RestoreDelay = new Stat(StatType.ShieldRestoreDelay, RestoreDelayTime);
		}
		public void InitFromConfig(float hp, float regen, float restoreDelay)
		{
			ShieldHP = new Stat(StatType.Shield, hp);
			ShieldRegen = new Stat(StatType.ShieldRegen, regen);
			RestoreDelay = new Stat(StatType.ShieldRestoreDelay, restoreDelay);
		}

		public bool ContainsAngle(float angle)
		{
			if (StartAngle <= EndAngle)
			{
				return angle >= StartAngle && angle <= EndAngle;
			}
			else
			{
				return angle >= StartAngle || angle <= EndAngle;
			}
		}

		public float Absorb(float damage)
		{
			if (ShieldHP.Current <= 0)
			{
				return damage;
			}
			damage *= (1f - DamageResist);
			float taken = Mathf.Min(damage, ShieldHP.Current);
			ShieldHP.AddToCurrent(-taken);
			return damage - taken;
		}

		public void Tick()
		{
			CurrentHp = ShieldHP.Current;
			Collider.enabled = ShieldHP.Current > 0;

			// Если щит упал — запускаем задержку
			if (ShieldHP.Current <= 0 && !IsRestoring)
			{
				CurrentRestoreTime = RestoreDelay.Current;
				IsRestoring = true;
			}

			// Обрабатываем задержку
			if (IsRestoring)
			{
				CurrentRestoreTime -= 1f;

				if (CurrentRestoreTime <= 0)
				{
					IsRestoring = false;
					ShieldHP.AddToCurrent(ShieldHP.Maximum * 0.1f);
				}
				GameEvent.UiUpdate();
				return;
			}

			// Нормальная регенерация раз в секунду
			if (ShieldHP.Current < ShieldHP.Maximum)
			{
				ShieldHP.AddToCurrent(ShieldRegen.Current);
			}
			GameEvent.UiUpdate();
		}


	}
}


// ---------- ShieldSectorVisual.cs ----------
using Ships;
using UnityEngine;

public class ShieldSectorVisual : MonoBehaviour
{
	[SerializeField] private SpriteRenderer sprite;
	public ShieldSide Side;
	private Material mat;

	int idCharge;
	int idStart;
	int idEnd;
	int idHitPoint;
	int idHitStrength;
	int idHitTime;

	float hitStrength;
	float hitTime;

	public void Init()
	{
		mat = Instantiate(sprite.material);
		sprite.material = mat;

		idCharge = Shader.PropertyToID("_Charge");
		idStart = Shader.PropertyToID("_SectorStart");
		idEnd = Shader.PropertyToID("_SectorEnd");
		idHitPoint = Shader.PropertyToID("_HitPoint");
		idHitStrength = Shader.PropertyToID("_HitStrength");
		idHitTime = Shader.PropertyToID("_HitTime");
	}

	private void Update()
	{
		if (hitStrength > 0)
		{
			hitTime += Time.deltaTime;
			hitStrength = Mathf.MoveTowards(hitStrength, 0, Time.deltaTime * 3f);
		}

		mat.SetFloat(idHitStrength, hitStrength);
		mat.SetFloat(idHitTime, hitTime);
	}

	public void SetSectorAngles(float start, float end)
	{
		mat.SetFloat(idStart, start);
		mat.SetFloat(idEnd, end);
	}

	public void SetCharge(float t)
	{
		mat.SetFloat(idCharge, t);
	}

	public void Hit(Vector2 worldPos)
	{
		Vector2 local = transform.InverseTransformPoint(worldPos);
		Vector2 uv = local * 0.5f + new Vector2(0.5f, 0.5f);

		mat.SetVector(idHitPoint, uv);
		hitStrength = 1f;
		hitTime = 0;
	}
}


// ---------- ShieldSide.cs ----------
namespace Ships
{
	public enum ShieldSide
	{
		Front,
		Left,
		Right,
		Rear,
		Omni
	}
}


// ---------- BattleUi.cs ----------
using System;
using System.Collections;
using UnityEngine;

namespace Ships
{
	public class BattleUi : MonoBehaviour
	{
		[SerializeField] private PlayerShipStatsContainerUi _playerShipStatsContainer;
		[SerializeField] private float _updateRatio = 0.01f;
		private void Awake()
		{
			_playerShipStatsContainer = GetComponentInChildren<PlayerShipStatsContainerUi>();
		}

		private void Start()
		{
			GameEvent.OnUiUpdate += OnUpdate;
		}

		private void OnDestroy()
		{
			GameEvent.OnUiUpdate -= OnUpdate;
		}

		private void OnUpdate()
		{
			if (_playerShipStatsContainer)
				_playerShipStatsContainer.OnUpdate();
		}
	}
}


// ---------- PlayerShipStatsContainerUi.cs ----------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Net.Mime;
using UnityEngine;
using UnityEngine.UI;

namespace Ships
{
	public class PlayerShipStatsContainerUi : MonoBehaviour
	{
		public List<ShieldUi> ShieldUis = new List<ShieldUi>();
		private ShieldController _shieldController;
		[SerializeField] private Image _hpBar;
		private static readonly int Fill = Shader.PropertyToID("_Fill");

		public void OnUpdate()
		{
			var ship = Battle.Instance.Player;
			if (ship)
			{
				if (!_shieldController)
					_shieldController = ship.GetComponent<ShieldController>();
				_hpBar.material.SetFloat(Fill, ship.ShipStats.GetStat(StatType.HitPoint).Amount);
			}

			if (_shieldController)
			{
				foreach (var sector in _shieldController.Sectors)
				{
					var ui = ShieldUis.Find(x => x.Side == sector.Side);
					ui.Image.material.SetFloat(Fill, sector.ShieldHP.Amount);
				}
			}
		}
		
		[System.Serializable]
		public class ShieldUi
		{
			public ShieldSide Side;
			public Image Image;
		}
	}
	
}


// ---------- SafeArea.cs ----------
using UnityEngine;

namespace Ships
{
	public class SafeArea : MonoBehaviour
	{
		private RectTransform _rectTransform;
		private Rect _lastSafeArea = new Rect(0, 0, 0, 0);
		private ScreenOrientation _lastOrientation;

		private void Awake()
		{
			_rectTransform = GetComponent<RectTransform>();
			ApplySafeArea();
		}

		private void Update()
		{
			if (_lastSafeArea != Screen.safeArea || _lastOrientation != Screen.orientation)
			{
				ApplySafeArea();
			}
		}

		private void ApplySafeArea()
		{
			var safe = Screen.safeArea;

			var anchorMin = safe.position;
			var anchorMax = safe.position + safe.size;

			anchorMin.x /= Screen.width;
			anchorMin.y /= Screen.height;
			anchorMax.x /= Screen.width;
			anchorMax.y /= Screen.height;

			_rectTransform.anchorMin = anchorMin;
			_rectTransform.anchorMax = anchorMax;

			_lastSafeArea = safe;
			_lastOrientation = Screen.orientation;
		}
	}
}


// ---------- AutoGridCellSizer.cs ----------
namespace Ships
{
	using UnityEngine;
	using UnityEngine.UI;

	[RequireComponent(typeof(GridLayoutGroup))]
	[ExecuteInEditMode]
	public class AutoGridCellSizer : MonoBehaviour
	{
		[SerializeField] private RectTransform _rect;
		[SerializeField] private GridLayoutGroup _grid;

		public int columns = 5; // число колонок

		private void Update()
		{
			if(!_rect && !_grid)
				return;
			float width = _rect.rect.width;
			float spacing = _grid.spacing.x * (columns - 1);
			float padding = _grid.padding.left + _grid.padding.right;

			float cellSize = (width - spacing - padding) / columns;

			_grid.cellSize = new Vector2(cellSize, cellSize);
		}
	}

}


// ---------- InventoryItemVisual.cs ----------
using UnityEngine;
using UnityEngine.UI;

namespace Ships
{
	public class InventoryItemVisual : MonoBehaviour
	{
		private InventoryItem _item;
		private System.Action<InventoryItem> _onClick;

		[Header("UI")]
		public Image Icon;
		public Text CountLabel;
		public Button Button;

		public void Init(InventoryItem item, System.Action<InventoryItem> onClick)
		{
			_item = item;
			_onClick = onClick;

			//CountLabel.text = item.Count.ToString();

			Button.onClick.RemoveAllListeners();
			Button.onClick.AddListener(() => _onClick(_item));
		}
	}
}


// ---------- InventoryVisual.cs ----------
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Ships
{
	public class InventoryVisual : MonoBehaviour
	{
		private InventoryView _view;

		public Transform ListRoot;
		public InventoryItemVisual ItemPrefab;

		public void Init(InventoryView view)
		{
			_view = view;

			// Подписываемся
			GameEvent.OnInventoryUpdated += UpdateVisual;
			GameEvent.OnItemSelected += OnItemSelected;
			UpdateVisual(_view.GetInventory());
		}

		private void OnDestroy()
		{
			GameEvent.OnInventoryUpdated -= UpdateVisual;
			GameEvent.OnItemSelected -= OnItemSelected;
		}

		private void UpdateVisual(PlayerInventoryModel inventory)
		{
			Debug.Log("Update inventory, items: " + inventory.InventoryUniqueItems.Count);
			foreach (Transform child in ListRoot)
				Destroy(child.gameObject);

			foreach (var item in inventory.InventoryUniqueItems)
			{
				Debug.Log($"Load item: {item.ItemId}");
				var visual = Instantiate(ItemPrefab, ListRoot);
				visual.Init(item, OnItemClicked);
			}
		}

		private void OnItemClicked(InventoryItem item)
		{
			_view.InstallFromInventory(item);
		}

		private void OnItemSelected(InventoryItem item)
		{
			// Будущее: отображение описания предмета
			// UI: показываем stats, описание и т.д.
		}
	}


}


// ---------- MetaVisual.cs ----------
using UnityEngine;

namespace Ships
{
	public class MetaVisual : MonoBehaviour
	{
		public ShipFitVisual ShipFitVisual;
		public InventoryVisual InventoryVisual;

		public void OpenInventory()
		{
			
		}
	}
}


// ---------- ShipFitSlotVisual.cs ----------
using UnityEngine;
using UnityEngine.UI;

namespace Ships
{
	public class ShipFitSlotVisual : MonoBehaviour
	{
		public string SlotId;
		public bool IsWeapon;

		private ShipFitView _view;

		public void Init(ShipFitView view)
		{
			_view = view;
		}

		public void OnClick()
		{
			_view.OnSlotClicked(SlotId, IsWeapon);
		}

		public void SetIcon(Sprite sprite)
		{
			GetComponent<Image>().sprite = sprite;
		}
	}
}


// ---------- ShipFitVisual.cs ----------
using System.Collections.Generic;
using UnityEngine;

namespace Ships
{
	public class ShipFitVisual : MonoBehaviour
	{
		private ShipFitView _view;
		public List<ShipFitSlotVisual> WeaponSlots = new();  // 4 UI слота
		public List<ShipFitSlotVisual> ActiveSlots = new();  // 4 UI слота
		public List<ShipFitSlotVisual> PassiveSlots = new(); // 4 UI слота
		public List<ShipFitSlotVisual> HullSlots = new();    // 4 UI слота

		public void Init(ShipFitView view)
		{
			_view = view;
		}

		public void OnWeaponSlotClicked(string slotId)
		{
			_view.OnSlotClicked(slotId, isWeaponSlot: true);
		}

		public void UpdateSlotIcon(string slotId, Sprite icon)
		{
			// Находит UI-элемент, обновляет спрайт
		}

		public void UpdateSlot(string arg1, bool arg2)
		{
			
		}
	}

}


// ---------- DamageOverTimeEffect.cs ----------
using System.Collections;
using UnityEngine;

namespace Ships.HitEffect
{
    public class DamageOverTimeEffect : IStackableEffect
    {
        public string EffectId => "Burn";

        public bool CanStack { get; }
        public int MaxStacks { get; }

        private float chance;
        private float damagePerTick;
        private float duration;

        public DamageOverTimeEffect(
            float chance,
            float damagePerTick,
            float duration,
            bool canStack = true,
            int maxStacks = 5)
        {
            this.chance = chance;
            this.damagePerTick = damagePerTick;
            this.duration = duration;
            this.CanStack = canStack;
            this.MaxStacks = maxStacks;
        }

        public void Apply(ITargetable target, float damage, WeaponBase sourceWeapon)
        {
            if (Random.value > chance)
                return;

            if (target is not ShipBase ship)
                return;

            // 1) Стакаем/обновляем эффект на корабле
            ship.AddOrStackEffect(this, duration);

            // 2) Если DoT уже работает — НЕ запускать второй
            if (ship.RunningDotEffects.Contains(EffectId))
                return;

            // 3) Иначе запускаем DoT
            ship.RunningDotEffects.Add(EffectId);
            ship.StartCoroutine(DoDamageOverTime(ship));
        }

        private IEnumerator DoDamageOverTime(ShipBase ship)
        {
            while (true)
            {
                var eff = ship.GetEffect(EffectId);

                // Эффект исчез → снимаем
                if (eff == null)
                    break;

                // наносим фиксированный урон (НЕ зависит от стаков)
                if (ship.TryGetStat(StatType.HitPoint, out var hpStat))
                    hpStat.AddToCurrent(-damagePerTick);

                yield return new WaitForSeconds(1f);
            }

            // эффект закончился → символически убираем DoT из активных потоков
            ship.RunningDotEffects.Remove(EffectId);
        }
    }
}



// ---------- SlowEffect.cs ----------
using UnityEngine;

namespace Ships.HitEffect
{
	public class SlowEffect : IStackableEffect
	{
		public string EffectId => "Slow";
		public bool CanStack { get; }
		public int MaxStacks { get; }

		private float chance;
		private float slowPercent;
		private float duration;

		public SlowEffect(float chance, float slowPercent, float duration, bool canStack = false, int maxStacks = 1)
		{
			this.chance = chance;
			this.slowPercent = slowPercent;
			this.duration = duration;
			this.CanStack = canStack;
			this.MaxStacks = maxStacks;
		}

		public void Apply(ITargetable target, float damage, WeaponBase sourceWeapon)
		{
			if (Random.value > chance) return;
			if (!(target is ShipBase ship)) return;

			// 1) Обновить стаки
			ship.AddOrStackEffect(this, duration);

			// 2) Удалить старые модификаторы
			var stat = ship.GetStat(StatType.MoveSpeed) as Stat;
			stat.RemoveModifiersFromSource(this);

			// 3) Наложить новый модификатор
			var inst = ship.GetEffect(EffectId);

			float totalSlow = slowPercent / 100f * inst.Stacks;

			stat.AddModifier(new StatModifier(
				StatModifierType.PercentAdd,
				StatModifierTarget.Maximum,
				StatModifierPeriodicity.Timed,
				-totalSlow,
				remainingTicks: Mathf.CeilToInt(duration),
				source: this
			));
		}
	}



}


