// ---------- IDamagable.cs ----------

	public interface IDamagable
	{
		public void DoDamage();
	}



// ---------- IVisual.cs ----------
namespace Ships
{
	public interface IVisual
	{
		public abstract void Load();
		public abstract void Unload();
	}
}


// ---------- CodeCollector.cs ----------
using UnityEditor;
using UnityEngine;
using System.IO;
using System.Linq;

public static class CodeCollector
{
	private const string SourceFolder = "Assets/Scripts";
	private const string OutputFile = "AllSource.txt";

	[MenuItem("Tools/Code Collector/Collect All Scripts")]
	public static void Collect()
	{
		// Находим все .cs файлы
		string[] files = Directory.GetFiles(SourceFolder, "*.cs", SearchOption.AllDirectories);

		if (files.Length == 0)
		{
			Debug.LogWarning("CodeCollector: Не найдено ни одного .cs файла.");
			return;
		}

		// Собираем содержимое
		using (StreamWriter writer = new StreamWriter(OutputFile, false)) // false = перезаписывать каждый раз
		{
			foreach (string file in files)
			{
				writer.WriteLine($"// ---------- {Path.GetFileName(file)} ----------");
				string content = File.ReadAllText(file);
				writer.WriteLine(content);
				writer.WriteLine("\n");
			}
		}

		Debug.Log($"CodeCollector: Готово! Собранно {files.Length} скриптов → {OutputFile}");
		AssetDatabase.Refresh();
	}
}


// ---------- DebugStatsPanel.cs ----------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

using Ships;                     // твои статы
using Ships.HitEffect;          // эффекты
using Object = UnityEngine.Object;

public class DebugStatsPanel : EditorWindow
{
    private ShipBase targetShip;

    private Vector2 scrollStats;
    private Vector2 scrollEffects;

    private List<Type> effectTypes = new List<Type>();

    [MenuItem("Tools/Debug/Stats & Effects Panel")]
    public static void Open()
    {
        GetWindow<DebugStatsPanel>("Debug Stats Panel");
    }

    private void OnEnable()
    {
        RefreshEffects();
    }

    private void RefreshEffects()
    {
        effectTypes.Clear();

        var assemblies = AppDomain.CurrentDomain.GetAssemblies();

        foreach (var asm in assemblies)
        {
            foreach (var type in asm.GetTypes())
            {
                if (type.IsAbstract) continue;
                if (!typeof(IOnHitEffect).IsAssignableFrom(type)) continue;

                effectTypes.Add(type);
            }
        }
    }

    private void OnGUI()
    {
        EditorGUILayout.Space();

        DrawTargetSelector();

        EditorGUILayout.Space(8);

        if (targetShip != null)
        {
            DrawStats();
            EditorGUILayout.Space(12);
            DrawEffects();
        }
        else
        {
            EditorGUILayout.HelpBox("Select a ShipBase target.", MessageType.Info);
        }
    }

    private void DrawTargetSelector()
    {
        EditorGUILayout.LabelField("Target Ship", EditorStyles.boldLabel);
        targetShip = (ShipBase)EditorGUILayout.ObjectField(targetShip, typeof(ShipBase), true);

        if (GUILayout.Button("Refresh Effect List"))
        {
            RefreshEffects();
        }
    }

    private void DrawStats()
    {
        EditorGUILayout.LabelField("Stats", EditorStyles.boldLabel);
        scrollStats = EditorGUILayout.BeginScrollView(scrollStats, GUILayout.Height(250));

        foreach (var statPair in targetShip.ShipStats.All)
        {
            var stat = statPair.Value;

            EditorGUILayout.BeginVertical("box");
            EditorGUILayout.LabelField($"{stat.Name}", EditorStyles.boldLabel);
            EditorGUILayout.LabelField($"Base:    {stat.BaseCurrent} / {stat.BaseMaximum}");
            EditorGUILayout.LabelField($"Current: {stat.Current} / {stat.Maximum}");

            if (stat.Modifiers.Count > 0)
            {
                EditorGUILayout.LabelField("Modifiers:");

                foreach (var mod in stat.Modifiers)
                {
                    EditorGUILayout.BeginVertical("box");
                    EditorGUILayout.LabelField($"Type: {mod.Type}");
                    EditorGUILayout.LabelField($"Target: {mod.Target}");
                    EditorGUILayout.LabelField($"Value: {mod.Value}");
                    EditorGUILayout.LabelField($"Periodicity: {mod.Periodicity}");
                    EditorGUILayout.LabelField($"Ticks left: {mod.RemainingTicks}");
                    EditorGUILayout.LabelField($"Source: {mod.Source}");
                    EditorGUILayout.EndVertical();
                }
            }
            else
            {
                EditorGUILayout.LabelField("No modifiers.");
            }
            EditorGUILayout.LabelField("Active Effects", EditorStyles.boldLabel);

            foreach (var e in targetShip.ActiveEffects)
            {
                EditorGUILayout.BeginVertical("box");
                EditorGUILayout.LabelField($"Effect: {e.EffectName}");
                EditorGUILayout.LabelField($"Remaining: {e.Remaining}/{e.Duration}");
                EditorGUILayout.EndVertical();
            }

            EditorGUILayout.EndVertical();
        }

        EditorGUILayout.EndScrollView();
    }

    private void DrawEffects()
    {
        EditorGUILayout.LabelField("Available Hit Effects", EditorStyles.boldLabel);
        scrollEffects = EditorGUILayout.BeginScrollView(scrollEffects, GUILayout.Height(300));

        foreach (var type in effectTypes)
        {
            EditorGUILayout.BeginVertical("box");

            EditorGUILayout.LabelField(type.Name, EditorStyles.boldLabel);

            ConstructorInfo ctor = type.GetConstructors().FirstOrDefault();

            if (ctor == null)
            {
                EditorGUILayout.HelpBox("No public constructor found!", MessageType.Error);
                EditorGUILayout.EndVertical();
                continue;
            }

            var parameters = ctor.GetParameters();
            object[] args = new object[parameters.Length];

            // Draw editable fields for constructor parameters
            for (int i = 0; i < parameters.Length; i++)
            {
                var p = parameters[i];

                if (p.ParameterType == typeof(float))
                {
                    args[i] = EditorGUILayout.FloatField(p.Name, PlayerPrefs.GetFloat($"{type.Name}_{p.Name}", 1f));
                    PlayerPrefs.SetFloat($"{type.Name}_{p.Name}", (float)args[i]);
                }
                else if (p.ParameterType == typeof(int))
                {
                    args[i] = EditorGUILayout.IntField(p.Name, PlayerPrefs.GetInt($"{type.Name}_{p.Name}", 1));
                    PlayerPrefs.SetInt($"{type.Name}_{p.Name}", (int)args[i]);
                }
                else if (p.ParameterType.IsEnum)
                {
                    args[i] = EditorGUILayout.EnumPopup(p.Name, (Enum)Enum.ToObject(p.ParameterType, 0));
                }
                else
                {
                    EditorGUILayout.LabelField($"{p.Name}: unsupported type {p.ParameterType.Name}");
                }
            }

            // APPLY EFFECT
            if (GUILayout.Button("Apply To Target"))
            {
                var effect = (IOnHitEffect)ctor.Invoke(args);

                var target = (ITargetable)targetShip;

                effect.Apply(target, damage: 0, sourceWeapon: null);

                Debug.Log($"[Debug Panel] Applied {type.Name} to {targetShip.name}");
            }

            EditorGUILayout.EndVertical();
        }

        EditorGUILayout.EndScrollView();
    }
}



// ---------- ShipDebuggerWindow.cs ----------
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using Ships;

public class ShipDebuggerWindow : EditorWindow
{
    private Vector2 scroll;

    GUIStyle redBold;
    GUIStyle header;
    GUIStyle box;

    [MenuItem("Tools/ARPG SHIPS/Ship Debugger")]
    public static void Open()
    {
        GetWindow<ShipDebuggerWindow>("Ship Debugger");
    }
    private void EnsureStyles()
    {
        if (redBold == null)
        {
            redBold = new GUIStyle(EditorStyles.label)
            {
                normal = { textColor = new Color(1f, 0.25f, 0.25f) },
                fontStyle = FontStyle.Bold
            };
        }

        if (header == null)
        {
            header = new GUIStyle(EditorStyles.boldLabel)
            {
                fontSize = 13
            };
        }

        if (box == null)
        {
            box = new GUIStyle("box")
            {
                padding = new RectOffset(10, 10, 10, 10)
            };
        }
    }

    private void OnGUI()
    {
        EnsureStyles();
        if(!Application.isPlaying)
            return;
        scroll = EditorGUILayout.BeginScrollView(scroll);

        var ships = FindObjectsByType<ShipBase>(FindObjectsSortMode.None);

        foreach (var ship in ships)
        {
            DrawShip(ship);
            GUILayout.Space(15);
        }

        EditorGUILayout.EndScrollView();
    }

    // -----------------------------------------------------------
    // SHIP BLOCK
    // -----------------------------------------------------------
    private void DrawShip(ShipBase ship)
    {
        GUILayout.BeginVertical(box);

        EditorGUILayout.LabelField(ship.name, header);

        GUILayout.BeginHorizontal();
        GUILayout.Box("ICON", GUILayout.Width(80), GUILayout.Height(80));

        GUILayout.BeginVertical();
        DrawStats(ship);
        GUILayout.Space(5);
        DrawActiveEffects(ship);
        GUILayout.EndVertical();

        GUILayout.EndHorizontal();

        GUILayout.Space(10);
        DrawWeapons(ship);

        GUILayout.EndVertical();
    }

    // -----------------------------------------------------------
    // SHIP STATS
    // -----------------------------------------------------------
    private void DrawStats(ShipBase ship)
    {
        foreach (var kv in ship.ShipStats.All)
        {
            Stat stat = kv.Value;
            EditorGUILayout.LabelField($"{kv.Key}: {stat.Current}/{stat.Maximum}");
        }

        // Draw modifier list compactly
        foreach (var kv in ship.ShipStats.All)
        {
            Stat stat = kv.Value;

            if (stat.Modifiers.Count == 0)
                continue;

            foreach (var mod in stat.Modifiers)
            {
                string txt = FormatModifier(stat.Name, mod);

                if (mod.Periodicity == StatModifierPeriodicity.Timed)
                    txt += $" ({mod.RemainingTicks}s)";

                EditorGUILayout.LabelField(txt, redBold);
            }
        }
    }

    private string FormatModifier(StatType type, StatModifier mod)
    {
        string sign = mod.Value >= 0 ? "+" : "-";
        float val = Mathf.Abs(mod.Value);

        return mod.Type switch
        {
            StatModifierType.Flat        => $"Buff {sign}{val} {type}",
            StatModifierType.PercentAdd  => $"Buff {sign}{val * 100}% {type}",
            StatModifierType.PercentMult => $"x{1 + mod.Value} {type}",
            StatModifierType.Set         => $"Set {type} = {mod.Value}",
            _ => "Modifier"
        };
    }

    // -----------------------------------------------------------
    // ACTIVE EFFECTS (DoT, Burn, Slow, Buffs)
    // -----------------------------------------------------------
    private void DrawActiveEffects(ShipBase ship)
    {
        if (ship.ActiveEffects.Count == 0)
        {
            EditorGUILayout.LabelField("No active effects", EditorStyles.miniLabel);
            return;
        }

        foreach (var eff in ship.ActiveEffects)
        {
            EditorGUILayout.LabelField(
                $"{eff.EffectName} ({eff.Remaining:F0}/{eff.Duration:F0}s)",
                redBold
            );
        }
    }

    // -----------------------------------------------------------
    // WEAPON SECTION
    // -----------------------------------------------------------
    private void DrawWeapons(ShipBase ship)
    {
        if (ship.WeaponController == null)
        {
            EditorGUILayout.LabelField("No weapons", EditorStyles.miniLabel);
            return;
        }

        EditorGUILayout.LabelField("Weapons:", header);

        foreach (var slot in ship.WeaponController.Weapons)
        {
            if (slot == null || slot.MountedWeapon == null)
            {
                EditorGUILayout.LabelField("Slot empty");
                continue;
            }

            var w = slot.MountedWeapon;

            GUILayout.BeginVertical(box);
            EditorGUILayout.LabelField(w.name, EditorStyles.boldLabel);

            if (w.Model != null)
            {
                EditorGUILayout.LabelField(
                    $"FireRate {w.Model.FireRate}/s | Projectile {w.Model.ProjectileSpeed} | Range {w.Model.FireRange}");

                EditorGUILayout.LabelField(
                    $"Damage {w.Model.MinDamage}-{w.Model.MaxDamage} | Crit {w.Model.CritChance * 100}% x{w.Model.CritMultiplier}");

                EditorGUILayout.LabelField($"Accuracy {w.Model.Accuracy}");
            }

            DrawWeaponTargeting(slot);

            GUILayout.EndVertical();
        }
    }

    private void DrawWeaponTargeting(WeaponSlot slot)
    {
        if (slot.WeaponTargeting == null)
            return;

        var wt = slot.WeaponTargeting;

        // Private field "currentTarget"
        var f = wt.GetType().GetField("currentTarget",
            System.Reflection.BindingFlags.NonPublic |
            System.Reflection.BindingFlags.Instance);

        var t = f?.GetValue(wt) as ITargetable;

        EditorGUILayout.LabelField("Status: " + (t != null ? "firing" : "idle"),
            t != null ? redBold : EditorStyles.miniLabel);
    }
}



// ---------- DummyTarget.cs ----------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Ships.Mobs
{
	public class DummyTarget : ShipBase
	{
		private void Start()
		{
			ShipStats = new Stats();
			ShipStats.AddStat(new Stat(StatType.HP, 100));
			ShipStats.AddStat(new Stat(StatType.Shield, 50));
			ShipStats.AddStat(new Stat(StatType.MoveSpeed, 10));

			Init();
		}
	}
}


// ---------- ActiveEffectVisual.cs ----------
namespace Ships
{
	[System.Serializable]
	public class ActiveEffectVisual
	{
		public string EffectName;
		public float Duration;
		public float Remaining;

		public ActiveEffectVisual(string name, float duration)
		{
			EffectName = name;
			Duration = duration;
			Remaining = duration;
		}
	}

}


// ---------- ITargetable.cs ----------
using UnityEngine;

namespace Ships
{
	public interface ITargetable : IStatsProvider
	{
		Transform Transform { get; }
		bool IsAlive { get; }
		TargetSize Size { get; }
		Vector2 Velocity { get; }
	}

}


// ---------- PlayerShip.cs ----------
using System.Collections.Generic;

namespace Ships
{
	public class PlayerShip : ShipBase
	{
		
		private void Awake()
		{
			ShipStats = new Stats();
			ShipStats.AddStat(new Stat(StatType.HP, 100));
			ShipStats.AddStat(new Stat(StatType.Shield, 50));
			ShipStats.AddStat(new Stat(StatType.MoveSpeed, 10));
			ShipStats.AddStat(new Stat(StatType.KineticResist, 5));
			ShipStats.AddStat(new Stat(StatType.ExplosionResist, 5));
			Init();
		}
		
	}
}


// ---------- ShipBase.cs ----------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Ships
{
	public abstract class ShipBase : MonoBehaviour, ITargetable
	{
		public ShipVisual _visual;
		public SideType SideType;
		public Stats ShipStats;
		public List<StatVisual> StatVisuals = new List<StatVisual>();
		public List<ActiveEffectVisual> ActiveEffects = new();
		public WeaponController WeaponController;
		public Transform Transform => transform;

		public bool IsAlive
		{
			get
			{
				if (ShipStats.TryGetStat(StatType.HP, out var hp))
					return hp.Current > 0;
				return true;
			}
		}

		[SerializeField] private TargetSize size = TargetSize.Medium;
		public TargetSize Size => size;

		private Vector3 _lastPos;
		private Vector2 _velocity;
		public Vector2 Velocity => _velocity;

		public void Init()
		{
			if (_visual != null)
			{
				_visual.Unload();
				_visual.Load();
			}
			else
			{
				_visual = new ShipVisual();
				_visual.Load();
			}

			StartCoroutine(Tick());

			StatVisuals.Clear();
			foreach (var kvp in ShipStats.All)
			{
				StatVisuals.Add(new StatVisual { Name = kvp.Key });
			}

			_lastPos = transform.position;
		}

		private IEnumerator Tick()
		{
			while (true)
			{
				yield return new WaitForSeconds(1f);

				ShipStats.Tick();
				for (int i = ActiveEffects.Count - 1; i >= 0; i--)
				{
					var eff = ActiveEffects[i];
					eff.Remaining -= 1f;

					if (eff.Remaining <= 0)
						ActiveEffects.RemoveAt(i);
				}
			}
		}

		public void AddActiveEffect(string effectName, float duration)
		{
			ActiveEffects.Add(new ActiveEffectVisual(effectName, duration));
		}

		private void Update()
		{
			// обновляем Velocity
			var pos = transform.position;
			_velocity = (pos - _lastPos) / Time.deltaTime;
			_lastPos = pos;

			// обновляем StatVisuals
			foreach (var kvp in ShipStats.All)
			{
				var statType = kvp.Key;
				var stat = kvp.Value;

				foreach (var visual in StatVisuals)
				{
					if (visual.Name == statType)
					{
						visual.BaseCurrent = stat.BaseCurrent;
						visual.BaseMaximum = stat.BaseMaximum;
						visual.Current = stat.Current;
						visual.Maximum = stat.Maximum;

						visual.ModifierVisuals.Clear();
						foreach (var mod in stat.Modifiers)
						{
							visual.ModifierVisuals.Add(new StatModifierVisual
							{
								Type = mod.Type,
								Target = mod.Target,
								Periodicity = mod.Periodicity,
								Value = mod.Value,
								RemainingTicks = mod.RemainingTicks,
								SourceName = mod.Source?.ToString()
							});
						}
					}
				}
			}
			
			WeaponController.OnUpdate();
		}

		public bool TryGetStat(StatType name, out IStat stat)
		{
			bool result = ShipStats.TryGetStat(name, out var s);
			stat = s;
			return result;
		}

		public IStat GetStat(StatType name) => ShipStats.GetStat(name);

		public IEnumerable<IStat> GetAllStats() => ShipStats.All.Values;
	}
}


// ---------- ShipVisual.cs ----------
namespace Ships
{
	public sealed class ShipVisual : VisualBase
	{
		public override void Load()
		{
		
		}

		public override void Unload()
		{
			
		}
	}
}


// ---------- SideType.cs ----------
namespace Ships
{
	public enum SideType
	{
		Player,
		Enemy,
		Ally
	}
}


// ---------- TargetSize.cs ----------
namespace Ships
{
	public enum TargetSize
	{
		Small,
		Medium,
		Large
	}
}


// ---------- VisualBase.cs ----------
namespace Ships
{
	public abstract class VisualBase : IVisual
	{
		public abstract void Load();

		public abstract void Unload();
	}
}


// ---------- WeaponController.cs ----------
using System.Collections.Generic;
using UnityEngine;

namespace Ships
{
	[System.Serializable]
	public class WeaponController
	{
		public List<WeaponSlot> Weapons = new List<WeaponSlot>();
		//TODO must remove
		public List<GameObject> EnemyList = new List<GameObject>();

		public void OnUpdate()
		{
			List<ITargetable> _targetables = new List<ITargetable>();
			foreach (var eGameObject in EnemyList)
			{
				_targetables.Add(eGameObject.GetComponent<ITargetable>());
			}
			foreach (var weapon in Weapons)
			{
				weapon.WeaponTargeting.SetEnemies(_targetables);
			}
		}
	}
}


// ---------- IStat.cs ----------
namespace Ships
{
	public interface IStat
	{
		StatType Name { get; }

		float BaseMaximum { get; }
		float BaseCurrent { get; }

		float Maximum { get; }
		float Current { get; }

		void AddModifier(StatModifier modifier);
		void RemoveModifier(StatModifier modifier);
		void RemoveModifiersFromSource(object source);

		void AddToCurrent(float delta);

		void Tick();
	}
}


// ---------- IStatsProvider.cs ----------
using System.Collections.Generic;

namespace Ships
{
	public interface IStatsProvider
	{
		bool TryGetStat(StatType name, out IStat stat);
		IStat GetStat(StatType name);
		IEnumerable<IStat> GetAllStats();
	}
}


// ---------- Stat.cs ----------
using System.Collections.Generic;

namespace Ships
{
	public sealed class Stat : IStat
	{
		public StatType Name { get; }
		public float BaseMaximum { get; private set; }
		public float BaseCurrent { get; private set; }
		public float Maximum { get; private set; }
		public float Current { get; private set; }

		private readonly List<StatModifier> _modifiers = new List<StatModifier>();
		public IReadOnlyList<StatModifier> Modifiers => _modifiers;

		public Stat(StatType name, float baseMaximum, float? baseCurrent = null)
		{
			Name = name;
			BaseMaximum = baseMaximum;
			BaseCurrent = baseCurrent ?? baseMaximum;
			Maximum = BaseMaximum;
			Current = BaseCurrent;
		}

		public void SetBaseValues(float baseMaximum, float? baseCurrent = null, bool resetCurrentToFull = false)
		{
			BaseMaximum = baseMaximum;
			BaseCurrent = baseCurrent ?? BaseMaximum;
			Recalculate(resetCurrentToFull);
		}

		public void SetBaseMaximum(float baseMaximum, bool resetCurrentToFull = false)
		{
			BaseMaximum = baseMaximum;
			Recalculate(resetCurrentToFull);
		}

		public void SetBaseCurrent(float baseCurrent)
		{
			BaseCurrent = baseCurrent;
			Recalculate(false);
		}

		public void AddToCurrent(float delta)
		{
			Current += delta;
			if (Current > Maximum)
				Current = Maximum;
			if (Current < 0)
				Current = 0;
		}

		public void AddModifier(StatModifier modifier)
		{
			_modifiers.Add(modifier);
			Recalculate(false);
		}

		public void RemoveModifier(StatModifier modifier)
		{
			if (_modifiers.Remove(modifier))
			{
				Recalculate(false);
			}
		}

		public void RemoveModifiersFromSource(object source)
		{
			if (source == null)
				return;

			var changed = false;
			for (int i = _modifiers.Count - 1; i >= 0; i--)
			{
				if (_modifiers[i].Source == source)
				{
					_modifiers.RemoveAt(i);
					changed = true;
				}
			}

			if (changed)
			{
				Recalculate(false);
			}
		}

		public void Tick()
		{
			var changed = false;

			for (int i = _modifiers.Count - 1; i >= 0; i--)
			{
				var mod = _modifiers[i];
				if (mod.Periodicity == StatModifierPeriodicity.Timed)
				{
					mod.RemainingTicks--;
					if (mod.RemainingTicks <= 0)
					{
						_modifiers.RemoveAt(i);
						changed = true;
					}
				}
			}

			if (changed)
			{
				Recalculate(false);
			}
		}

		private void Recalculate(bool resetCurrentToFull)
		{
			var previousMax = Maximum > 0 ? Maximum : BaseMaximum;
			var previousRatio = previousMax > 0 ? Current / previousMax : 1f;
			
			var newMaximum = ApplyModifiers(BaseMaximum, StatModifierTarget.Maximum);
			var newCurrentBase = resetCurrentToFull ? newMaximum : BaseCurrent;
			var newCurrent = ApplyModifiers(newCurrentBase, StatModifierTarget.Current);
			var hasCurrentMods = HasModifiersForTarget(StatModifierTarget.Current);
			
			if (!hasCurrentMods && !resetCurrentToFull)
			{
				newCurrent = newMaximum * previousRatio;
			}
			if (newCurrent > newMaximum)
				newCurrent = newMaximum;
			if (newCurrent < 0)
				newCurrent = 0;

			Maximum = newMaximum;
			Current = newCurrent;
		}

		private bool HasModifiersForTarget(StatModifierTarget target)
		{
			for (int i = 0; i < _modifiers.Count; i++)
			{
				if (_modifiers[i].Target == target)
					return true;
			}

			return false;
		}
		
		private float ApplyModifiers(float baseValue, StatModifierTarget target)
		{
			var flatAdd = 0f;
			var percentAdd = 0f;
			var percentMult = 1f;
			var hasSet = false;
			var setValue = 0f;

			for (int i = 0; i < _modifiers.Count; i++)
			{
				var mod = _modifiers[i];
				if (mod.Target != target)
					continue;

				switch (mod.Type)
				{
					case StatModifierType.Flat:
						flatAdd += mod.Value;
						break;

					case StatModifierType.PercentAdd:
						percentAdd += mod.Value;
						break;

					case StatModifierType.PercentMult:
						percentMult *= (1f + mod.Value);
						break;

					case StatModifierType.Set:
						hasSet = true;
						setValue = mod.Value;
						break;
				}
			}

			var value = baseValue + flatAdd;
			value *= (1f + percentAdd);
			value *= percentMult;

			if (hasSet)
				value = setValue;

			return value;
		}
	}
}


// ---------- StatModifier.cs ----------
namespace Ships
{
	public sealed class StatModifier
	{
		public StatModifierType Type { get; }
		public StatModifierTarget Target { get; }
		public StatModifierPeriodicity Periodicity { get; }

		/// <summary>
		/// Величина модификатора:
		/// Flat: +X
		/// PercentAdd/PercentMult: X = 0.1f => +10%
		/// Set: новое значение.
		/// </summary>
		public float Value { get; }

		public int RemainingTicks { get; set; }
		public object Source { get; }

		public StatModifier(
			StatModifierType type,
			StatModifierTarget target,
			StatModifierPeriodicity periodicity,
			float value,
			int remainingTicks = 0,
			object source = null)
		{
			Type = type;
			Target = target;
			Periodicity = periodicity;
			Value = value;
			RemainingTicks = remainingTicks;
			Source = source;
		}
	}
}


// ---------- StatModifierTypes.cs ----------
namespace Ships
{
	/// <summary>
	/// Тип изменения величины.
	/// </summary>
	public enum StatModifierType
	{
		/// <summary>
		/// Плоская прибавка: value = value + X
		/// </summary>
		Flat,

		/// <summary>
		/// Суммарный процент: value = value * (1 + sum)
		/// </summary>
		PercentAdd,

		/// <summary>
		/// Мультипликативный процент: value = value * product(1 + X)
		/// </summary>
		PercentMult,

		/// <summary>
		/// Жёсткая установка: value = X
		/// </summary>
		Set
	}

	/// <summary>
	/// К какой части стата применяется модификатор.
	/// </summary>
	public enum StatModifierTarget
	{
		Current,
		Maximum
	}

	/// <summary>
	/// Периодичность действия модификатора.
	/// </summary>
	public enum StatModifierPeriodicity
	{
		/// <summary>
		/// Действует постоянно, пока явно не удалён.
		/// </summary>
		Permanent,

		/// <summary>
		/// Ограничен количеством тиков.
		/// </summary>
		Timed
	}
}


// ---------- StatModifierVisual.cs ----------
namespace Ships
{
	[System.Serializable]
	public class StatModifierVisual
	{
		public StatModifierType Type;
		public StatModifierTarget Target;
		public StatModifierPeriodicity Periodicity;
		public float Value;
		public int RemainingTicks;
		public string SourceName;
	}
}


// ---------- Stats.cs ----------
using System.Collections.Generic;
using UnityEngine;

namespace Ships
{
	public sealed class Stats
	{
		private readonly Dictionary<StatType, Stat> _stats = new Dictionary<StatType, Stat>();

		public IReadOnlyDictionary<StatType, Stat> All => _stats;

		public void AddStat(Stat stat)
		{
			_stats[stat.Name] = stat;
		}

		public bool TryGetStat(StatType name, out Stat stat)
		{
			return _stats.TryGetValue(name, out stat);
		}

		public Stat GetStat(StatType name)
		{
			_stats.TryGetValue(name, out var stat);
			return stat;
		}

		public float GetCurrent(StatType name)
		{
			if (!_stats.TryGetValue(name, out var stat))
			{
				Debug.LogError($"Stat {name} not found in Stats!");
				return 0f;
			}
			return stat.Current;
		}

		public float GetMaximum(StatType name)
		{
			return _stats.TryGetValue(name, out var stat) ? stat.Maximum : 0f;
		}
		
		public void Tick()
		{
			foreach (var stat in _stats.Values)
			{
				stat.Tick();
			}
		}
	}
}


// ---------- StatType.cs ----------
namespace Ships
{
	public enum StatType
	{
		// Ship
		HP,
		MoveSpeed,
		TurnSpeed,
		Shield,
		ShieldRegen,

		// Weapon
		FireRate,
		MinDamage,
		MaxDamage,
		CritChance,
		CritMultiplier,
		ProjectileSpeed,
		ArmorPierce,
		FireRange,
		Accuracy,

		// Resistances
		KineticResist,
		ThermalResist,
		ExplosionResist,
	}
}


// ---------- StatVisual.cs ----------
using System.Collections.Generic;

namespace Ships
{
	[System.Serializable]
	public class StatVisual
	{
		public StatType Name;
		public float BaseMaximum;
		public float BaseCurrent;
		public float Maximum;
		public float Current;

		public List<StatModifierVisual> ModifierVisuals = new List<StatModifierVisual>();
	}
}


// ---------- IOnHitEffect.cs ----------
namespace Ships
{
	public interface IOnHitEffect
	{
		void Apply(ITargetable target, float damage, WeaponBase sourceWeapon);
	}
}


// ---------- Projectile.cs ----------
using UnityEngine;

namespace Ships
{
	using UnityEngine;

	public class Projectile : MonoBehaviour
	{
		private Transform target;
		private float speed;
		private float damage;
		private float armorPierce;
		private WeaponBase sourceWeapon;

		public void Init(Transform target, float dmg, float spd, float ap, WeaponBase source)
		{
			this.target = target;
			damage = dmg;
			speed = spd;
			armorPierce = ap;
			sourceWeapon = source;
		}

		void Update()
		{
			if (target == null)
			{
				Destroy(gameObject);
				return;
			}

			Vector2 dir = (target.position - transform.position).normalized;
			transform.position += (Vector3)(dir * speed * Time.deltaTime);

			if (Vector2.Distance(transform.position, target.position) < 0.2f)
				HitTarget();
		}

		private void HitTarget()
		{
			if (target.TryGetComponent<ITargetable>(out var targetable))
			{
				// нанести урон
				if (targetable.TryGetStat(StatType.HP, out var hpStat))
					hpStat.AddToCurrent(-damage);

				// вызвать эффекты
				foreach (var effect in sourceWeapon.Model.Effects)
					effect.Apply(targetable, damage, sourceWeapon);
			}

			Destroy(gameObject);
		}
	}

}


// ---------- ProjectileWeapon.cs ----------
using System;

namespace Ships
{
	using UnityEngine;

	public class ProjectileWeapon : WeaponBase
	{
		public Projectile ProjectilePrefab;
		private bool IsInit;
		private void Update()
		{
			//TODO
			if (Model != null && !IsInit)
			{
				Stats stats = new Stats();
				stats.AddStat(new Stat(StatType.FireRange, 25));
				stats.AddStat(new Stat(StatType.FireRate, 1));
				stats.AddStat(new Stat(StatType.ProjectileSpeed, 3));
				stats.AddStat(new Stat(StatType.MinDamage, 5));
				stats.AddStat(new Stat(StatType.MaxDamage, 10));
				stats.AddStat(new Stat(StatType.Accuracy, 1));
				stats.AddStat(new Stat(StatType.CritChance, 0.05f));
				stats.AddStat(new Stat(StatType.CritMultiplier, 1.2f));
				Model.InjectStat(stats);
				IsInit = true;
			}
		}

		protected override void Shoot(Transform target)
		{
			float damage = RollDamage();
			float speed = Model.ProjectileSpeed;

			if (speed <= 0.01f)
			{
				DoInstantHit(target, damage);
			}
			else
			{
				//var proj = Instantiate(ProjectilePrefab, FirePoint.position, FirePoint.rotation);
				//proj.Init(target, damage, speed, Model.ArmorPierce, this);
			}
		}

		private void DoInstantHit(Transform target, float dmg)
		{
			if (target.TryGetComponent<ITargetable>(out var t))
			{
				if (t.TryGetStat(StatType.HP, out var hp))
					hp.AddToCurrent(-dmg);

				foreach (var effect in Model.Effects)
					effect.Apply(t, dmg, this);
			}
		}
	}
}


// ---------- WeaponBase.cs ----------
using System;
using UnityEngine;

namespace Ships
{
	using UnityEngine;

	public abstract class WeaponBase : MonoBehaviour
	{

		protected float nextFireTime;

		public WeaponSlot Slot;
		public WeaponModel Model;
		public Transform FirePoint;

		public void Init(Stats stats)
		{
			Model = new WeaponModel(stats);
		}
		public void Init(WeaponSlot slot)
		{
			Model = new WeaponModel();
			Slot = slot;
		}

		public void TickWeapon(Transform target)
		{
			if (Model == null || target == null)
				return;

			Vector2 dir = (target.position - Slot.transform.position);

			RotateToTarget(dir);

			if (Time.time >= nextFireTime)
			{
				nextFireTime = Time.time + 1f / Model.FireRate;
				Shoot(target);
			}
		}

		// NEW: Tick with aim point (using lead + accuracy)
		public void TickWeaponPosition(Vector2 aimPoint)
		{
			if (Model == null)
				return;

			Vector2 dir = aimPoint - (Vector2)Slot.transform.position;
			RotateToTarget(dir);
		}

		protected virtual void RotateToTarget(Vector2 direction)
		{
			if (!Slot.IsTurret)
				return;

			float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
			Quaternion rot = Quaternion.Euler(0, 0, angle);
			transform.rotation = Quaternion.Lerp(Slot.transform.rotation, rot, Time.deltaTime * 10f);
		}

		protected abstract void Shoot(Transform target);

		protected float RollDamage()
		{
			float dmg = Random.Range(Model.MinDamage, Model.MaxDamage);

			if (Random.value < Model.CritChance)
				dmg *= Model.CritMultiplier;

			return dmg;
		}
	}

}



// ---------- WeaponModel.cs ----------
using System.Collections.Generic;

namespace Ships
{
	public class WeaponModel
	{
		private Stats Stats { get; set; }
		private readonly List<IOnHitEffect> _effects = new();

		public void AddEffect(IOnHitEffect effect) => _effects.Add(effect);
		public IReadOnlyList<IOnHitEffect> Effects => _effects;

		public WeaponModel(Stats stats = null)
		{
			Stats = stats;
		}

		public void InjectStat(Stats newStats)
		{
			Stats = newStats;
		}

		// --- SAFE GETTER ---
		private float Safe(StatType t)
		{
			if (Stats == null) return 0;
			return Stats.GetCurrent(t);
		}

		public float FireRate        => Safe(StatType.FireRate);
		public float MinDamage       => Safe(StatType.MinDamage);
		public float MaxDamage       => Safe(StatType.MaxDamage);
		public float CritChance      => Safe(StatType.CritChance);
		public float CritMultiplier  => Safe(StatType.CritMultiplier);
		public float ProjectileSpeed => Safe(StatType.ProjectileSpeed);
		public float ArmorPierce     => Safe(StatType.ArmorPierce);
		public float FireRange       => Safe(StatType.FireRange);
		public float Accuracy        => Safe(StatType.Accuracy);
	}



}


// ---------- WeaponSlot.cs ----------
using System;

namespace Ships
{
	using UnityEngine;

	public class WeaponSlot : MonoBehaviour
	{
		public float AllowedAngle = 45f; 
		public bool IsTurret = false;
		public WeaponBase MountedWeapon;
		public WeaponTargeting WeaponTargeting;
		

		private void Start()
		{
			if (transform.childCount > 0)
			{
				MountedWeapon = transform.GetComponentInChildren<WeaponBase>();
				WeaponTargeting = transform.GetComponentInChildren<WeaponTargeting>();
			}

			if (MountedWeapon)
			{
				MountedWeapon.Init(this);
			}
				
		}

		public bool IsTargetWithinSector(Vector2 dir)
		{
			Vector2 forward = transform.right; 
			var angle = Vector2.Angle(forward, dir);
			return angle <= AllowedAngle;
		}
	}

}


// ---------- WeaponTargeting.cs ----------
namespace Ships
{
	using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class WeaponTargeting : MonoBehaviour
{
    public WeaponBase Weapon;
    public WeaponSlot Slot;

    public TargetSize PriorityType = TargetSize.Small;

    private List<ITargetable> enemies = new();
    private ITargetable currentTarget;

    public void SetEnemies(List<ITargetable> list)
    {
        enemies = list;
    }

    void Update()
    {
        if (!Slot)
        {
            Slot = GetComponentInParent<WeaponSlot>();
        }
        if(!Slot)
            return;
        
        SelectTargetIfNeeded();

        if (currentTarget == null)
            return;
        Vector2 aim = GetAimPoint(currentTarget);

        Weapon.TickWeaponPosition(aim);
        Weapon.TickWeapon(currentTarget.Transform);
    }

    private void SelectTargetIfNeeded()
    {
        if (currentTarget == null)
        {
            currentTarget = FindTarget();
            return;
        }

        if (!currentTarget.IsAlive || !IsTargetInSector(currentTarget) || !IsTargetInRange(currentTarget))
        {
            currentTarget = FindTarget();
        }
    }

    private bool IsTargetInRange(ITargetable t)
    {
        float dist = Vector2.Distance(Slot.transform.position, t.Transform.position);
        return dist <= Weapon.Model.FireRange;
    }

    private bool IsTargetInSector(ITargetable t)
    {
        Vector2 dir = (t.Transform.position - Slot.transform.position).normalized;
        return Slot.IsTargetWithinSector(dir);
    }

    private ITargetable FindTarget()
    {
        Vector2 pos = Slot.transform.position;

        var inRange = enemies
            .Where(e =>
            {
                if (e.IsAlive) 
                    return true;
                return false;
            })
            .Where(e =>
            {
                if (Vector2.Distance(pos, e.Transform.position) <= Weapon.Model.FireRange)
                    return true;
                return false;
            })
            .Where(e => {
                Vector2 dir = ((Vector2)e.Transform.position - pos).normalized;
                return Slot.IsTargetWithinSector(dir);
            })
            .ToList();

        if (inRange.Count == 0)
            return null;

        var priority = inRange
            .Where(e => e.Size == PriorityType)
            .OrderBy(e => Vector2.Distance(pos, e.Transform.position))
            .FirstOrDefault();

        if (priority != null)
            return priority;

        return inRange
            .OrderBy(e => Vector2.Distance(pos, e.Transform.position))
            .FirstOrDefault();
    }

    private Vector2 GetAimPoint(ITargetable t)
    {
        Vector2 pos = Slot.transform.position;
        Vector2 targetPos = t.Transform.position;
        Vector2 vel = t.Velocity;

        float speed = Weapon.Model.ProjectileSpeed;

        Vector2 dir;

        if (speed > 0.01f)
        {
            float dist = Vector2.Distance(pos, targetPos);
            float time = dist / speed;

            Vector2 predicted = targetPos + vel * time;
            dir = (predicted - pos).normalized;
        }
        else
        {
            dir = (targetPos - pos).normalized;
        }

        dir = ApplyAccuracy(dir);

        return pos + dir * 12f;
    }

    private Vector2 ApplyAccuracy(Vector2 dir)
    {
        float acc = Weapon.Model.Accuracy;

        if (Random.value <= acc)
            return dir;

        float maxAngle = 15f * (1f - acc);
        float a = Random.Range(-maxAngle, maxAngle) * Mathf.Deg2Rad;

        float cos = Mathf.Cos(a);
        float sin = Mathf.Sin(a);

        return new Vector2(
            dir.x * cos - dir.y * sin,
            dir.x * sin + dir.y * cos
        );
    }
}

}


// ---------- DamageOverTimeEffect.cs ----------
using System.Collections;
using UnityEngine;

namespace Ships.HitEffect
{
	public class DamageOverTimeEffect : IOnHitEffect
	{
		private float chance;
		private float damagePerTick;
		private float duration;

		public DamageOverTimeEffect(float chance, float damagePerTick, float duration)
		{
			this.chance = chance;
			this.damagePerTick = damagePerTick;
			this.duration = duration;
		}

		public void Apply(ITargetable target, float damage, WeaponBase sourceWeapon)
		{
			if (UnityEngine.Random.value > chance)
				return;

			// показать эффект в UI / Debug Panel
			if (target is ShipBase ship)
				ship.AddActiveEffect("Burn", duration);

			// наносим урон
			if (target is MonoBehaviour mb)
				mb.StartCoroutine(DoDamageOverTime(target));
		}

		private IEnumerator DoDamageOverTime(ITargetable target)
		{
			int ticks = Mathf.CeilToInt(duration);

			for (int i = 0; i < ticks; i++)
			{
				if (!target.IsAlive)
					yield break;

				if (target.TryGetStat(StatType.HP, out var hpStat))
					hpStat.AddToCurrent(-damagePerTick);

				yield return new WaitForSeconds(1f);
			}
		}
	}

}


// ---------- SlowEffect.cs ----------
using UnityEngine;

namespace Ships.HitEffect
{
	public class SlowEffect : IOnHitEffect
	{
		private float chance;
		private float slowPercent; // 10 = 10%
		private float duration;    // секунды

		public SlowEffect(float chance, float slowPercent, float duration)
		{
			this.chance = chance;
			this.slowPercent = slowPercent;
			this.duration = duration;
		}

		public void Apply(ITargetable target, float damage, WeaponBase sourceWeapon)
		{
			if (UnityEngine.Random.value > chance)
				return;

			if (target.TryGetStat(StatType.MoveSpeed, out var stat))
			{
				float fraction = slowPercent / 100f;

				stat.AddModifier(
					new StatModifier(
						StatModifierType.PercentAdd,
						StatModifierTarget.Maximum,
						StatModifierPeriodicity.Timed,
						-fraction,
						remainingTicks: Mathf.CeilToInt(duration), // <== 1 секунда = 1 тик
						source: this
					)
				);
			}
		}
	}


}


